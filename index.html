<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Plummet Protect</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    font-family: sans-serif;
    overflow-y: auto;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
  }
  canvas {
    display: block;
    cursor: crosshair;
    touch-action: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
  }
  #ui {
    position: fixed;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 10px;
    background: rgba(0,0,0,0.5);
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    z-index: 100;
  }
  #ui span { padding: 4px 10px; border-radius: 10px; background: rgba(255,255,255,0.1); font-size: 12px; opacity: 0.85; }
  #hudLives { font-size: 16px !important; color: #f87171 !important; opacity: 1 !important; }
  #hudLevel { font-size: 16px !important; color: #fbbf24 !important; opacity: 1 !important; }
  #startScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(26,26,46,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    z-index: 200;
    color: #fff;
    overflow-y: auto;
    padding: 40px 20px 30px;
    -webkit-overflow-scrolling: touch;
  }
  #startScreen.gone { display: none; }
  #homeTokenBadge {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    border-radius: 20px;
    background: rgba(251, 191, 36, 0.15);
    border: 1.5px solid rgba(251, 191, 36, 0.4);
    color: #fbbf24;
    font-size: 15px;
    font-weight: 700;
    z-index: 210;
    flex-shrink: 0;
  }
  #homeTokenBadge .token-icon {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: #1a1a2e;
    font-weight: 900;
    box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
  }
  #startScreen h1 {
    font-size: 58px;
    color: #8ec5fc;
    margin-bottom: 10px;
    flex-shrink: 0;
  }
  .meteor-icon {
    display: inline-block;
    width: 52px;
    height: 52px;
    vertical-align: middle;
    margin: 0 -4px -4px -4px;
    filter: drop-shadow(0 0 8px rgba(255, 120, 30, 0.7));
    animation: meteorFall 2.5s ease-in-out infinite;
  }
  @keyframes meteorFall {
    0%, 100% { transform: translate(0, -3px); filter: drop-shadow(0 0 8px rgba(255, 120, 30, 0.7)); }
    50% { transform: translate(0, 5px); filter: drop-shadow(0 0 16px rgba(255, 80, 10, 1)); }
  }
  .shield-word {
    position: relative;
    display: inline-block;
    padding: 4px 14px;
    color: #b8e4ff;
    -webkit-text-fill-color: #b8e4ff;
  }
  .shield-word::before {
    content: '';
    position: absolute;
    top: -10px; left: -18px; right: -18px; bottom: -10px;
    border-radius: 50%;
    border: 2px solid rgba(142, 212, 255, 0.5);
    box-shadow:
      0 0 14px rgba(142, 212, 255, 0.4),
      0 0 28px rgba(142, 212, 255, 0.15),
      inset 0 0 14px rgba(142, 212, 255, 0.1);
    animation: shieldPulse 2s ease-in-out infinite;
  }
  .hex-grid {
    position: absolute;
    top: -10px; left: -18px;
    width: calc(100% + 36px);
    height: calc(100% + 20px);
    pointer-events: none;
    overflow: hidden;
    border-radius: 50%;
  }
  .hex-grid polygon {
    fill: none;
    stroke: rgba(142, 212, 255, 0.25);
    stroke-width: 0.8;
    animation: hexFlicker 3s ease-in-out infinite;
  }
  .hex-grid polygon:nth-child(odd) { animation-delay: 0.5s; }
  .hex-grid polygon:nth-child(3n) { animation-delay: 1s; }
  .hex-grid polygon:nth-child(4n+1) { animation-delay: 1.5s; }
  @keyframes shieldPulse {
    0%, 100% { opacity: 0.6; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.04); }
  }
  @keyframes hexFlicker {
    0%, 100% { stroke: rgba(142, 212, 255, 0.15); }
    50% { stroke: rgba(142, 212, 255, 0.5); }
  }
  #startScreen > p { opacity: 0.6; margin-bottom: 14px; flex-shrink: 0; }
  #startScreen .info { font-size: 14px; line-height: 1.8; opacity: 0.75; margin-bottom: 20px; margin-top: 60px; text-align: center; max-width: 380px; flex-shrink: 0; }
  #startScreen > button {
    padding: 14px 44px; font-size: 18px; font-weight: 700;
    border: none; border-radius: 30px;
    background: linear-gradient(135deg, #5eead4, #2dd4bf);
    color: #1a1a2e; cursor: pointer;
    flex-shrink: 0;
  }
  #shopSection {
    width: 100%;
    max-width: 400px;
    margin-top: 20px;
    flex-shrink: 0;
  }
  #shopSection h3 {
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 2px;
    opacity: 0.5;
    text-align: center;
    margin-bottom: 12px;
  }
  #powerups {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
  }
  .upgradeBtn {
    padding: 18px 20px;
    font-size: 16px; font-weight: 600;
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 16px;
    background: rgba(255,255,255,0.06);
    color: #fff;
    cursor: pointer;
    display: flex; align-items: center; gap: 10px;
    -webkit-tap-highlight-color: transparent;
    justify-content: center;
    text-align: center;
    white-space: nowrap;
  }
  .upgradeBtn:hover {
    background: rgba(255,255,255,0.12);
    border-color: rgba(255,255,255,0.4);
  }
  .upgradeBtn.active {
    background: rgba(94,234,212,0.15);
    border-color: #5eead4;
    color: #5eead4;
  }
  #backBtn, #pauseBtn, #muteBtn {
    position: fixed;
    top: 50px;
    width: 48px; height: 48px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
    background: rgba(0,0,0,0.4);
    color: #fff; font-size: 22px;
    cursor: pointer; z-index: 100;
    display: flex; align-items: center; justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }
  #backBtn { left: 15px; }
  #pauseBtn { right: 15px; }
  #muteBtn { right: 70px; }
  #shieldBtn {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    width: 56px; height: 56px;
    border-radius: 50%;
    border: 3px solid #fbbf24;
    background: radial-gradient(circle at 35% 35%, #fde68a, #d4940a);
    color: #1a1a2e; font-size: 24px;
    cursor: pointer; z-index: 100;
    display: none; align-items: center; justify-content: center;
    -webkit-tap-highlight-color: transparent;
    box-shadow: 0 0 15px rgba(251, 191, 36, 0.5);
    transition: all 0.3s ease;
  }
  #shieldBtn.used {
    border-color: #9ca3af;
    background: radial-gradient(circle at 35% 35%, #d1d5db, #6b7280);
    box-shadow: 0 0 8px rgba(156, 163, 175, 0.3);
    cursor: default;
    opacity: 0.7;
    animation: shieldShatter 0.4s ease-out;
  }
  @keyframes shieldShatter {
    0% { transform: translateX(-50%) scale(1); }
    20% { transform: translateX(-50%) scale(1.1); }
    50% { transform: translateX(-50%) scale(0.9); }
    100% { transform: translateX(-50%) scale(1); }
  }
  #shieldBtn .shield-label {
    position: absolute;
    bottom: -18px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 9px;
    font-weight: bold;
    white-space: nowrap;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  }
  #pauseOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 300;
    color: #fff;
  }
  #gameOverScreen, #settingsScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 300;
    color: #fff;
  }
  #pauseOverlay.show, #gameOverScreen.show, #settingsScreen.show { display: flex; }
  #settingsScreen h2 { font-size: 36px; margin-bottom: 20px; }
  .settings-row {
    display: flex; align-items: center; justify-content: space-between;
    width: 280px; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  .settings-row label { font-size: 16px; font-weight: 600; }
  .settings-slider { width: 120px; accent-color: #5eead4; cursor: pointer; }
  .settings-btn {
    margin-top: 16px; padding: 12px 30px; font-size: 16px; font-weight: 600;
    border: 2px solid rgba(255,255,255,0.2); border-radius: 12px;
    background: rgba(255,255,255,0.06); color: #fff; cursor: pointer;
  }
  .settings-btn:hover { background: rgba(255,255,255,0.12); transform: scale(1.05); }
  button:hover { transform: scale(1.05); transition: transform 0.15s; }
  button:active { transform: scale(0.95); }
  .settings-btn.danger { border-color: #f87171; color: #f87171; }
  .settings-btn.danger:hover { background: rgba(248,113,113,0.15); }
  .best-stats { display: flex; gap: 20px; margin-bottom: 16px; text-align: center; font-size: 13px; opacity: 0.7; }
  .best-stats div span { display: block; font-size: 22px; font-weight: bold; opacity: 1; color: #5eead4; }
  #statsScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 300;
    color: #fff;
    padding: 30px;
  }
  #statsScreen.show { display: flex; }
  #statsScreen h2 { font-size: 32px; margin-bottom: 20px; }
  .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px 30px;
    margin-bottom: 24px;
    text-align: center;
  }
  .stats-grid .stat-val {
    font-size: 26px; font-weight: 700;
    background: linear-gradient(135deg, #5eead4, #8ec5fc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .stats-grid .stat-label { font-size: 11px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }
  #lineColorSelector {
    display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
    margin-top: 10px; max-width: 300px;
  }
  .line-color-btn {
    width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.2);
    cursor: pointer; transition: all 0.2s;
  }
  .line-color-btn.active { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); transform: scale(1.15); }
  .line-color-btn.locked { opacity: 0.3; cursor: not-allowed; }
  #comboMultiplier {
    position: fixed;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    font-weight: 900;
    color: #fbbf24;
    text-shadow: 0 0 15px rgba(251,191,36,0.8);
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  #pauseOverlay h2 { font-size: 48px; margin-bottom: 20px; }
  #gameOverScreen h2 {
    font-size: 42px; margin-bottom: 8px;
    background: linear-gradient(135deg, #ff6b6b, #fbbf24);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  #gameOverScreen .go-sub { opacity: 0.5; font-size: 14px; margin-bottom: 24px; }
  #gameOverScreen .go-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 24px;
    margin-bottom: 28px;
    text-align: center;
  }
  #gameOverScreen .go-stats .stat-val {
    font-size: 28px; font-weight: 700;
    background: linear-gradient(135deg, #5eead4, #8ec5fc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  #gameOverScreen .go-stats .stat-label { font-size: 11px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }
  #pauseOverlay button, #gameOverScreen button {
    padding: 14px 44px; font-size: 18px; font-weight: 700;
    border: none; border-radius: 30px;
    background: linear-gradient(135deg, #5eead4, #2dd4bf);
    color: #1a1a2e; cursor: pointer;
    margin: 8px;
    -webkit-tap-highlight-color: transparent;
  }
  #tutorial {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 400;
    color: #fff;
    text-align: center;
    padding: 30px;
  }
  #tutorial.show { display: flex; }
  #tutorial h2 {
    font-size: 32px;
    margin-bottom: 20px;
    background: linear-gradient(135deg, #5eead4, #2dd4bf);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  #tutorial .step {
    font-size: 18px;
    line-height: 2;
    max-width: 400px;
    margin-bottom: 24px;
    opacity: 0.9;
  }
  #tutorial .hand-icon {
    font-size: 60px;
    margin-bottom: 16px;
    animation: swipe 2s ease-in-out infinite;
  }
  @keyframes swipe {
    0%, 100% { transform: translate(-30px, -10px) rotate(-20deg); }
    50% { transform: translate(30px, 10px) rotate(10deg); }
  }
  #tutorial button {
    padding: 14px 44px; font-size: 18px; font-weight: 700;
    border: none; border-radius: 30px;
    background: linear-gradient(135deg, #5eead4, #2dd4bf);
    color: #1a1a2e; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  /* World Map / Level Select (item 11) */
  #worldMapScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.9);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    z-index: 300;
    color: #fff;
    overflow-y: auto;
    padding: 30px 20px;
  }
  #worldMapScreen.show { display: flex; }
  #worldMapScreen h2 { font-size: 32px; margin-bottom: 20px; }
  .world-map-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
    max-width: 380px;
    width: 100%;
  }
  .world-map-node {
    width: 60px; height: 60px;
    border-radius: 50%;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    font-size: 16px; font-weight: 700;
    cursor: pointer;
    border: 3px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.08);
    transition: all 0.2s;
    position: relative;
    margin: 0 auto;
  }
  .world-map-node.unlocked { border-color: #5eead4; background: rgba(94,234,212,0.15); }
  .world-map-node.locked { opacity: 0.3; cursor: not-allowed; border-color: #555; }
  .world-map-node .node-stars { font-size: 10px; color: #fbbf24; margin-top: 2px; }
  /* Milestone popup (item 14) */
  #milestonePopup {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20, 20, 50, 0.95);
    border: 3px solid #fbbf24;
    border-radius: 20px;
    padding: 30px 40px;
    color: #fff;
    text-align: center;
    z-index: 500;
    display: none;
    box-shadow: 0 0 40px rgba(251,191,36,0.3);
  }
  #milestonePopup.show { display: block; }
  #milestonePopup h3 { font-size: 24px; color: #fbbf24; margin-bottom: 10px; }
  #milestonePopup p { font-size: 16px; opacity: 0.8; margin-bottom: 16px; }
  #milestonePopup button {
    padding: 10px 30px; font-size: 16px; font-weight: 700;
    border: none; border-radius: 20px;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #1a1a2e; cursor: pointer;
  }
  /* Skill Tree */
  #skillTreeSection { width: 100%; max-width: 400px; margin-top: 16px; }
  #skillTreeSection h3 { font-size: 14px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.5; text-align: center; margin-bottom: 12px; }
  .skill-tree-paths { display: flex; gap: 8px; width: 100%; }
  .skill-path { flex: 1; display: flex; flex-direction: column; gap: 6px; }
  .skill-path-title { font-size: 12px; font-weight: 700; text-align: center; padding: 4px; border-radius: 8px; margin-bottom: 4px; }
  .skill-node { padding: 10px 6px; font-size: 11px; font-weight: 600; border: 2px solid rgba(255,255,255,0.15); border-radius: 10px; background: rgba(255,255,255,0.04); color: #fff; cursor: pointer; text-align: center; transition: all 0.2s; }
  .skill-node:hover { background: rgba(255,255,255,0.1); }
  .skill-node.owned { border-color: #5eead4; background: rgba(94,234,212,0.15); color: #5eead4; }
  .skill-node.locked { opacity: 0.35; cursor: not-allowed; }
  .skill-connector { width: 2px; height: 10px; background: rgba(255,255,255,0.15); margin: 0 auto; }
  .skill-connector.owned { background: #5eead4; }
  /* Season Pass */
  #seasonPassBar { width: 100%; max-width: 380px; margin-top: 14px; padding: 10px 14px; border-radius: 12px; background: rgba(255,255,255,0.06); border: 1.5px solid rgba(192,132,252,0.3); }
  #seasonPassBar .sp-title { font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px; opacity: 0.5; margin-bottom: 6px; text-align: center; color: #c084fc; }
  #seasonPassBar .sp-bar-bg { width: 100%; height: 8px; border-radius: 4px; background: rgba(255,255,255,0.1); overflow: hidden; }
  #seasonPassBar .sp-bar-fill { height: 100%; border-radius: 4px; background: linear-gradient(90deg, #c084fc, #a78bfa); transition: width 0.3s; }
  #seasonPassBar .sp-info { display: flex; justify-content: space-between; font-size: 10px; opacity: 0.6; margin-top: 4px; }
  /* Leaderboard */
  #leaderboardScreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 300; color: #fff; overflow-y: auto; padding: 40px 20px; }
  #leaderboardScreen.show { display: flex; }
  #leaderboardScreen h2 { font-size: 32px; margin-bottom: 20px; }
  .lb-entry { display: flex; align-items: center; gap: 12px; padding: 10px 16px; width: 100%; max-width: 360px; border-radius: 10px; background: rgba(255,255,255,0.04); margin-bottom: 6px; font-size: 14px; }
  .lb-entry .lb-rank { font-size: 18px; font-weight: 700; color: #fbbf24; min-width: 30px; }
  .lb-entry .lb-score { flex: 1; }
  .lb-entry .lb-date { font-size: 11px; opacity: 0.4; }
  /* Difficulty Selector */
  #difficultySelector { display: flex; gap: 10px; margin-top: 10px; margin-bottom: 6px; }
  .diff-btn { padding: 8px 18px; font-size: 13px; font-weight: 700; border: 2px solid rgba(255,255,255,0.2); border-radius: 20px; background: rgba(255,255,255,0.06); color: #fff; cursor: pointer; transition: all 0.2s; }
  .diff-btn.active { border-color: #5eead4; background: rgba(94,234,212,0.15); color: #5eead4; }
  .diff-btn:hover { background: rgba(255,255,255,0.1); }
  @media (max-width: 600px) {
    #ui { font-size: 11px; gap: 6px; padding: 6px; }
    #ui span { padding: 3px 6px; }
    #startScreen { padding: 30px 16px 20px; }
    #startScreen h1 { font-size: 42px; }
    #startScreen .info { font-size: 12px; line-height: 1.6; }
    #startScreen > button { padding: 12px 32px; font-size: 16px; }
    #shopSection { max-width: 340px; }
    .upgradeBtn { padding: 14px 16px; font-size: 14px; }
    #powerups { gap: 8px; }
    #backBtn, #pauseBtn, #muteBtn { width: 44px; height: 44px; font-size: 20px; }
    .skill-tree-paths { flex-direction: column; }
  }
</style>
</head>
<body>

<div id="ui">
  <span id="hudLives">Lives: ****</span>
  <span id="hudLevel">Level 1</span>
  <span id="hudCrash">Crashes: 0/3</span>
  <span id="hudCombo">Combo: 0/4</span>
  <span id="hudStreak">Streak: 0</span>
  <span id="hudTokens" style="position:fixed; top:10px; right:10px;">Plummet Tokens: 0</span>
</div>

<canvas id="c"></canvas>

<button id="backBtn">&#8592;</button>
<button id="muteBtn" onclick="toggleMute()">&#128264;</button>
<button id="pauseBtn">&#10074;&#10074;</button>
<button id="shieldBtn" onclick="activateFloorShield()">&#128737;<span class="shield-label">POWER SHIELD</span></button>

<div id="pauseOverlay">
  <h2>Paused</h2>
  <button onclick="resumeGame()">Resume</button>
  <button onclick="quitToHome()">Quit to Home</button>
</div>

<div id="gameOverScreen">
  <h2>Game Over</h2>
  <p class="go-sub">3 crashes - back to Level 1</p>
  <div class="go-stats">
    <div><div class="stat-val" id="goLevel">-</div><div class="stat-label">Level Reached</div></div>
    <div><div class="stat-val" id="goCatches">-</div><div class="stat-label">Catches</div></div>
    <div><div class="stat-val" id="goTokens">-</div><div class="stat-label">Tokens Earned</div></div>
    <div><div class="stat-val" id="goStreak">-</div><div class="stat-label">Best Streak</div></div>
  </div>
  <button onclick="playAgain()">Play Again</button>
  <button id="shareScoreBtn" onclick="shareScore()" style="background: rgba(255,255,255,0.1); color: #fff; border: 2px solid rgba(255,255,255,0.3);">&#128279; Share Score</button>
  <button onclick="dismissGameOver()" style="background: rgba(255,255,255,0.1); color: #fff; border: 2px solid rgba(255,255,255,0.3);">Back to Menu</button>
</div>

<div id="tutorial">
  <div class="hand-icon" id="tutorialIcon">&#9997;</div>
  <h2 id="tutorialTitle">How to Play</h2>
  <div class="step" id="tutorialStep">
    Tap and drag to draw lines.<br>
    Objects will bounce off your lines!
  </div>
  <div style="display:flex; gap:10px;">
    <button id="tutorialNextBtn" onclick="nextTutorialStep()">Next</button>
  </div>
  <div id="tutorialDots" style="display:flex; gap:8px; margin-top:16px;"></div>
</div>


<div id="settingsScreen">
  <h2>Settings</h2>
  <div class="best-stats">
    <div>Best Level<span id="statBestLevel">-</span></div>
    <div>Best Streak<span id="statBestStreak">-</span></div>
    <div>Best Catches<span id="statBestCatches">-</span></div>
  </div>
  <div class="settings-row">
    <label>Music</label>
    <input type="range" class="settings-slider" id="musicVol" min="0" max="100" value="100" oninput="setMusicVol(this.value); document.getElementById('musicVolLabel').textContent=this.value+'%'">
    <span id="musicVolLabel" style="font-size:13px; min-width:40px; text-align:right;">100%</span>
  </div>
  <div class="settings-row">
    <label>SFX</label>
    <input type="range" class="settings-slider" id="sfxVol" min="0" max="100" value="100" oninput="setSfxVol(this.value); document.getElementById('sfxVolLabel').textContent=this.value+'%'">
    <span id="sfxVolLabel" style="font-size:13px; min-width:40px; text-align:right;">100%</span>
  </div>
  <div class="settings-row">
    <label>Colorblind Mode</label>
    <input type="checkbox" id="colorblindToggle" onchange="toggleColorblind(this.checked)" style="width:20px; height:20px; accent-color: #5eead4; cursor: pointer;">
  </div>
  <div class="settings-row">
    <label>High Contrast</label>
    <input type="checkbox" id="highContrastToggle" onchange="toggleHighContrast(this.checked)" style="width:20px; height:20px; accent-color: #5eead4; cursor: pointer;">
  </div>
  <div class="settings-row">
    <label>One-Hand Mode</label>
    <input type="checkbox" id="oneHandToggle" onchange="toggleOneHand(this.checked)" style="width:20px; height:20px; accent-color: #5eead4; cursor: pointer;">
  </div>
  <div class="settings-row">
    <label>Egg Skin</label>
    <select id="eggSkinSelect" onchange="setEggSkin(this.value)" style="background:#1a1a2e; color:#fff; border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:6px 10px; font-size:14px; cursor:pointer;">
      <option value="default">Default</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Trail Effect</label>
    <select id="trailSelect" onchange="setTrailEffect(this.value)" style="background:#1a1a2e; color:#fff; border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:6px 10px; font-size:14px; cursor:pointer;">
      <option value="sparkles">Sparkles</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Line Colour</label>
    <div id="lineColorSelector"></div>
  </div>
  <div class="settings-row">
    <label>Line Type</label>
    <select id="lineTypeSelect" onchange="setLineType(this.value)" style="background:#1a1a2e; color:#fff; border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:6px 10px; font-size:14px; cursor:pointer;">
      <option value="normal">Normal</option>
    </select>
  </div>
  <div class="settings-row">
    <label>Background</label>
    <select id="bgThemeSelect" onchange="setBgTheme(this.value)" style="background:#1a1a2e; color:#fff; border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:6px 10px; font-size:14px; cursor:pointer;">
      <option value="default">Default</option>
    </select>
  </div>
  <button class="settings-btn" onclick="closeSettings()">Back</button>
  <button class="settings-btn danger" onclick="confirmReset()">Reset All Progress</button>
</div>

<div id="startScreen">
  <div id="homeTokenBadge"><div class="token-icon">F</div><span id="homeTokenCount">0</span></div>
  <h1>Plumm<svg class="meteor-icon" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="mRock" cx="40%" cy="38%"><stop offset="0%" stop-color="#9e8e78"/><stop offset="25%" stop-color="#7a6650"/><stop offset="55%" stop-color="#54402a"/><stop offset="80%" stop-color="#3a2515"/><stop offset="100%" stop-color="#1e0f08"/></radialGradient><radialGradient id="mHot" cx="40%" cy="38%"><stop offset="0%" stop-color="#fffbe6"/><stop offset="15%" stop-color="#ffe44d"/><stop offset="35%" stop-color="#ff9911"/><stop offset="60%" stop-color="#dd4400"/><stop offset="85%" stop-color="#881100"/><stop offset="100%" stop-color="transparent"/></radialGradient><radialGradient id="mGlow" cx="45%" cy="45%"><stop offset="0%" stop-color="rgba(255,180,40,0.45)"/><stop offset="40%" stop-color="rgba(255,80,10,0.18)"/><stop offset="100%" stop-color="rgba(255,30,0,0)"/></radialGradient><linearGradient id="mTrail1" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#ffe44d"/><stop offset="40%" stop-color="#ff8800"/><stop offset="100%" stop-color="transparent"/></linearGradient><linearGradient id="mTrail2" x1="100%" y1="100%" x2="0%" y2="0%"><stop offset="0%" stop-color="#ff6600"/><stop offset="50%" stop-color="#cc2200"/><stop offset="100%" stop-color="transparent"/></linearGradient><filter id="mBlur1"><feGaussianBlur stdDeviation="1.5"/></filter><filter id="mBlur2"><feGaussianBlur stdDeviation="0.8"/></filter><filter id="mTurb"><feTurbulence type="fractalNoise" baseFrequency="0.15" numOctaves="4" result="noise"/><feDisplacementMap in="SourceGraphic" in2="noise" scale="2" xChannelSelector="R" yChannelSelector="G"/></filter></defs><circle cx="29" cy="29" r="24" fill="url(#mGlow)" filter="url(#mBlur1)"/><path d="M22,24 Q11,14 2,3" stroke="url(#mTrail1)" stroke-width="5" fill="none" stroke-linecap="round" filter="url(#mBlur1)"/><path d="M20,27 Q10,18 1,8" stroke="url(#mTrail2)" stroke-width="4" fill="none" stroke-linecap="round" filter="url(#mBlur1)"/><path d="M24,23 Q16,13 9,3" stroke="#ffcc33" stroke-width="2.5" fill="none" stroke-linecap="round" opacity="0.7" filter="url(#mBlur2)"/><path d="M19,29 Q11,22 4,14" stroke="#ee3300" stroke-width="2" fill="none" stroke-linecap="round" opacity="0.5" filter="url(#mBlur1)"/><path d="M23,26 Q17,18 13,10" stroke="#ffdd66" stroke-width="1.5" fill="none" stroke-linecap="round" opacity="0.55" filter="url(#mBlur2)"/><ellipse cx="29" cy="29" rx="11" ry="10" fill="url(#mRock)" transform="rotate(-30 29 29)" filter="url(#mTurb)"/><ellipse cx="27" cy="27" rx="5" ry="4" fill="#2a1808" opacity="0.5" transform="rotate(-20 27 27)"/><ellipse cx="33" cy="31" rx="3.5" ry="2.5" fill="#1e0f05" opacity="0.45" transform="rotate(15 33 31)"/><circle cx="26" cy="31" r="2" fill="#1a0c04" opacity="0.4"/><circle cx="31" cy="26" r="1.3" fill="#2a1505" opacity="0.5"/><ellipse cx="34" cy="34" rx="2" ry="1.5" fill="#160a02" opacity="0.35" transform="rotate(40 34 34)"/><path d="M24,28 Q22,26 24,24 Q26,22 28,24" fill="#443020" opacity="0.4"/><path d="M30,32 Q32,30 33,32" fill="#3a2515" opacity="0.35"/><ellipse cx="29" cy="28" rx="8" ry="7" fill="url(#mHot)" opacity="0.45" transform="rotate(-30 29 28)"/><ellipse cx="27" cy="26" rx="4" ry="3" fill="#ffeeaa" opacity="0.3" transform="rotate(-25 27 26)"/><ellipse cx="26" cy="25" rx="2" ry="1.2" fill="#fffde8" opacity="0.4" transform="rotate(-30 26 25)"/><circle cx="13" cy="14" r="1.8" fill="#ff8822" opacity="0.6" filter="url(#mBlur2)"/><circle cx="9" cy="10" r="1.2" fill="#ffaa33" opacity="0.5" filter="url(#mBlur2)"/><circle cx="6" cy="6" r="0.8" fill="#ffcc55" opacity="0.4"/><circle cx="16" cy="18" r="1" fill="#ff6611" opacity="0.5" filter="url(#mBlur2)"/><circle cx="4" cy="12" r="0.7" fill="#ff9933" opacity="0.35"/></svg>t <span class="shield-word">Protect<svg class="hex-grid" viewBox="0 0 160 60" xmlns="http://www.w3.org/2000/svg"><polygon points="30,2 42,10 42,26 30,34 18,26 18,10" /><polygon points="55,2 67,10 67,26 55,34 43,26 43,10" /><polygon points="80,2 92,10 92,26 80,34 68,26 68,10" /><polygon points="105,2 117,10 117,26 105,34 93,26 93,10" /><polygon points="130,2 142,10 142,26 130,34 118,26 118,10" /><polygon points="18,26 30,34 30,50 18,58 6,50 6,34" /><polygon points="43,26 55,34 55,50 43,58 31,50 31,34" /><polygon points="68,26 80,34 80,50 68,58 56,50 56,34" /><polygon points="93,26 105,34 105,50 93,58 81,50 81,34" /><polygon points="118,26 130,34 130,50 118,58 106,50 106,34" /><polygon points="143,26 155,34 155,50 143,58 131,50 131,34" /></svg></span></h1>
  <p>A Physics-Based Juggling Game</p>
  <p style="font-size: 13px; opacity: 0.6; max-width: 360px; text-align: center; margin-top: 6px; line-height: 1.5; flex-shrink: 0;">The sky is falling! Draw lines to bounce precious cargo into the safe zones before they shatter on the ground.</p>
  <div class="info">
    Draw lines with your mouse to bounce falling objects.<br>
    Guide them into the Safe Zone on the right wall.<br>
    You have 3 lives. Every 10 bounces heals you.<br>
    3 crashes resets to Level 1.<br>
    Spend Plummet Tokens in the shop to upgrade your skills.<br>
    <span style="opacity: 0.65; font-size: 11px;">Stars: &#9733;&#9733;&#9733; = No crashes, &#9733;&#9733; = 1 crash, &#9733; = 2+ crashes. Bonus for 15+ bounces!</span>
  </div>
  <div id="difficultySelector">
    <button class="diff-btn" onclick="setDifficulty('easy')">Easy</button>
    <button class="diff-btn active" onclick="setDifficulty('medium')">Medium</button>
    <button class="diff-btn" onclick="setDifficulty('hard')">Hard</button>
  </div>
  <button onclick="startGame()" style="position: relative; z-index: 210; padding: 16px 50px; font-size: 20px; box-shadow: 0 0 20px rgba(94,234,212,0.5);">Start Playing</button>
  <div id="seasonPassBar">
    <div class="sp-title">Season Pass</div>
    <div class="sp-bar-bg"><div class="sp-bar-fill" id="spBarFill" style="width:0%"></div></div>
    <div class="sp-info"><span id="spXpText">0 XP</span><span id="spTierText">Tier 0/10</span></div>
  </div>
  <div id="shopSection">
    <h3>Shop</h3>
    <div id="powerups">
      <button class="upgradeBtn" id="bounceHigherBtn" onclick="buyUpgrade('bounceHigher')" title="Objects bounce higher off your lines"><small id="bounceHigherLv">Lv:-</small> &#11014; Bounce Higher <small id="bounceHigherPrice">(75)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Objects bounce higher off your lines</p>
      <button class="upgradeBtn" id="widerLinesBtn" onclick="buyUpgrade('widerLines')" title="Draw thicker lines — easier to hit"><small id="widerLinesLv">Lv:-</small> &#9135; Wider Lines <small id="widerLinesPrice">(75)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Draw thicker lines — easier to hit</p>
      <button class="upgradeBtn" id="shieldFloorBtn" onclick="buyUpgrade('shieldFloor')" title="Protective shield at the bottom of the screen"><small id="shieldFloorLv">Lv:-</small> &#128737; Floor Shield <small id="shieldFloorPrice">(50)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Protective shield at the bottom of the screen</p>
      <button class="upgradeBtn" id="widerZonesBtn" onclick="buyUpgrade('widerZones')" title="Safe zones are wider"><small id="widerZonesLv">Lv:-</small> &#8596; Wider Safe Zones <small id="widerZonesPrice">(100)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Safe zones are wider, easier to catch objects</p>
      <button class="upgradeBtn" id="slowerMeteorsBtn" onclick="buyUpgrade('slowerMeteors')" title="Meteors fall slower"><small id="slowerMeteorsLv">Lv:-</small> &#9732; Slower Meteors <small id="slowerMeteorsPrice">(80)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Meteors fall slower — more time to react</p>
      <button class="upgradeBtn" id="fasterComboBtn" onclick="buyUpgrade('fasterCombo')" title="Combo meter fills faster"><small id="fasterComboLv">Lv:-</small> &#9889; Faster Combo Fill <small id="fasterComboPrice">(90)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Combo meter fills faster for quicker life recovery</p>
      <div style="margin-top:16px; margin-bottom:8px; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:2px; opacity:0.4;">Line Types</div>
      <button class="upgradeBtn" id="stickyLinesBtn" onclick="buyLineType('stickyLines')">&#129716; Sticky Lines <small id="stickyLinesPrice">(120)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Objects slow down 50% on contact</p>
      <button class="upgradeBtn" id="bouncyLinesBtn" onclick="buyLineType('bouncyLines')">&#129667; Bouncy Lines <small id="bouncyLinesPrice">(100)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">1.3x extra bounce force</p>
      <button class="upgradeBtn" id="curvedLinesBtn" onclick="buyLineType('curvedLines')">&#10160; Curved Lines <small id="curvedLinesPrice">(80)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Thicker lines with curve visual</p>
      <button class="upgradeBtn" id="conveyorLinesBtn" onclick="buyConveyorLines()">&#9654; Conveyor Lines <small id="conveyorLinesPrice">(150)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Slides objects along line toward safe zone</p>
      <div style="margin-top:16px; margin-bottom:8px; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:2px; opacity:0.4;">Portal Pairs</div>
      <button class="upgradeBtn" id="portalPairsBtn" onclick="buyPortalUpgrade()">&#128302; Portal Pairs <small id="portalPairsLv">Lv:0/3</small> <small id="portalPairsPrice">(200)</small></button>
      <p style="font-size: 11px; color: rgba(255,255,255,0.4); margin: -4px 0 4px 0; text-align: center;">Draw circles to place entry/exit portals</p>
      <div style="margin-top:16px; margin-bottom:8px; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:2px; opacity:0.4;">Egg Skins</div>
      <button class="upgradeBtn" id="galaxySkinBtn" onclick="buyEggSkin('galaxy')">&#127756; Galaxy Egg <small id="galaxySkinPrice">(50)</small></button>
      <button class="upgradeBtn" id="goldenSkinSkinBtn" onclick="buyEggSkin('goldenSkin')">&#11088; Golden Egg <small id="goldenSkinSkinPrice">(50)</small></button>
      <button class="upgradeBtn" id="neonSkinBtn" onclick="buyEggSkin('neon')">&#128154; Neon Egg <small id="neonSkinPrice">(50)</small></button>
      <div style="margin-top:16px; margin-bottom:8px; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:2px; opacity:0.4;">Trail Effects</div>
      <button class="upgradeBtn" id="flamesTrailBtn" onclick="buyTrail('flames')">&#128293; Flames Trail <small id="flamesTrailPrice">(75)</small></button>
      <button class="upgradeBtn" id="rainbowTrailBtn" onclick="buyTrail('rainbow')">&#127752; Rainbow Trail <small id="rainbowTrailPrice">(75)</small></button>
      <div style="margin-top:16px; margin-bottom:8px; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:2px; opacity:0.4;">Background Themes</div>
      <button class="upgradeBtn" id="neonCityBtn" onclick="buyBgTheme('neonCity')">&#127747; Neon City <small id="neonCityPrice">(200)</small></button>
      <button class="upgradeBtn" id="underwaterBtn" onclick="buyBgTheme('underwater')">&#127754; Underwater <small id="underwaterPrice">(200)</small></button>
      <button class="upgradeBtn" id="autumnBtn" onclick="buyBgTheme('autumn')">&#127810; Autumn <small id="autumnPrice">(200)</small></button>
    </div>
    <p id="tokenWarning" style="color: #ff6b6b; font-size: 13px; font-weight: bold; min-height: 20px; margin-top: 8px; opacity: 0; transition: opacity 1s ease;">&nbsp;</p>
  </div>
  <div id="skillTreeSection">
    <h3>Skill Tree</h3>
    <div class="skill-tree-paths" id="skillTreePaths"></div>
  </div>
  <button onclick="openWorldMap()" style="position: relative; z-index: 210; padding: 12px 36px; font-size: 16px; margin-top: 12px; border: 2px solid #8ec5fc; border-radius: 30px; background: rgba(142,197,252,0.15); color: #8ec5fc; font-weight: 700; cursor: pointer;">&#127758; Level Select</button>
  <div id="prestigeBtn" style="display:none; margin-top: 8px;"><button onclick="doPrestige()" style="padding: 10px 30px; font-size: 14px; border: 2px solid #c084fc; border-radius: 30px; background: rgba(192,132,252,0.15); color: #c084fc; font-weight: 700; cursor: pointer;">&#11088; Prestige (1.1x multiplier)</button></div>
  <button class="settings-btn" onclick="openLeaderboard()" style="margin-top: 16px; opacity: 0.6;">&#127942; Leaderboard</button>
  <button class="settings-btn" onclick="openStats()" style="margin-top: 8px; opacity: 0.6;">&#128202; Stats</button>
  <button class="settings-btn" onclick="openSettings()" style="margin-top: 10px; opacity: 0.6;">&#9881; Settings</button>
  <button class="settings-btn" onclick="openAchievements()" style="margin-top: 10px; opacity: 0.6;">&#127942; Achievements</button>
</div>

<div id="comboMultiplier"></div>

<div id="statsScreen">
  <h2>Stats</h2>
  <div class="stats-grid">
    <div><div class="stat-val" id="statTotalCatches">0</div><div class="stat-label">Total Catches</div></div>
    <div><div class="stat-val" id="statTotalGames">0</div><div class="stat-label">Total Games</div></div>
    <div><div class="stat-val" id="statFavObject">-</div><div class="stat-label">Favourite Object</div></div>
    <div><div class="stat-val" id="statBestLevelAll">0</div><div class="stat-label">Best Level</div></div>
    <div><div class="stat-val" id="statTotalTime">0m</div><div class="stat-label">Time Played</div></div>
    <div><div class="stat-val" id="statTotalTokensEarned">0</div><div class="stat-label">Total Tokens Earned</div></div>
  </div>
  <button class="settings-btn" onclick="closeStats()">Back</button>
</div>

<div id="achievementsScreen" style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); display:none; flex-direction:column; align-items:center; justify-content:flex-start; z-index:300; color:#fff; overflow-y:auto; padding:40px 20px;">
  <h2 style="font-size:32px; margin-bottom:20px;">Achievements</h2>
  <div id="achievementsList" style="display:flex; flex-wrap:wrap; gap:12px; justify-content:center; max-width:400px;"></div>
  <button class="settings-btn" onclick="closeAchievements()" style="margin-top:24px;">Back</button>
</div>

<div id="leaderboardScreen">
  <h2>Leaderboard</h2>
  <div id="leaderboardList" style="width:100%; max-width:360px;"></div>
  <button class="settings-btn" onclick="closeLeaderboard()" style="margin-top:24px;">Back</button>
</div>

<div id="worldMapScreen">
  <h2>World Map</h2>
  <div class="world-map-grid" id="worldMapGrid"></div>
  <button class="settings-btn" onclick="closeWorldMap()" style="margin-top:24px;">Back</button>
</div>

<div id="milestonePopup">
  <h3 id="milestoneTitle">Milestone!</h3>
  <p id="milestoneText"></p>
  <button onclick="closeMilestone()">Collect!</button>
</div>

<script>
// =============================================
// PLUMMET PROTECT
// =============================================

// roundRect polyfill for older browsers
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    this.moveTo(x + r[0], y);
    this.lineTo(x + w - r[1], y);
    this.arcTo(x + w, y, x + w, y + r[1], r[1]);
    this.lineTo(x + w, y + h - r[2]);
    this.arcTo(x + w, y + h, x + w - r[2], y + h, r[2]);
    this.lineTo(x + r[3], y + h);
    this.arcTo(x, y + h, x, y + h - r[3], r[3]);
    this.lineTo(x, y + r[0]);
    this.arcTo(x, y, x + r[0], y, r[0]);
    return this;
  };
}

// Catch any errors and show them on screen
var errorLog = [];
window.onerror = function(msg, url, line) {
  errorLog.push(msg + ' L' + line);
  return false;
};

var CW = window.innerWidth;
var CH = window.innerHeight;
var canvas = document.getElementById('c');
canvas.width = CW;
canvas.height = CH;
var ctx = canvas.getContext('2d');

// Disable right-click on canvas
canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

// Game state
var running = false;
var paused = false;
var hasSeenTutorial = localStorage.getItem('fluffTutorialSeen') === 'true';
var lives = 3;
var lifeFrac = 0;
var strikes = 0;
var combo = 0;
var level = 1;
var totalCatches = 0;
var fluffTokens = 0;
var bounceCount = 0;
var spawnTimer = 0;
var objects = [];
var lines = [];
var particles = [];
var texts = [];
var frameCount = 0;
var shakeAmount = 0;
var flashes = [];
var wind = 0;
var targetWind = 0;
var windTimer = 0;
var catchStreak = 0;
var bestStreakThisRun = 0;
var tokensThisRun = 0;
var maxLives = 3;
var activeEffects = { shield: 0, slowmo: 0, doubleTokens: 0, magnet: 0 }; // timers in ms
var slowmoFactor = 1;
var levelCrashes = 0; // crashes in current level
var levelBounces = 0; // bounces in current level

// Combo multiplier system (item 8)
var comboMultiplier = 1;
var comboMultiplierTimer = 0; // ms since last catch — resets on catch
var COMBO_TIMEOUT = 2500; // ms to maintain combo multiplier
var comboMultiplierDisplay = 0; // for fade animation

// Object preview (item 11)
var nextSpawnX = 0;
var nextSpawnReady = false;

// Prestige system (item 14)
var prestigeLevel = 0;
var prestigeMultiplier = 1.0;

// Line colors (item 12)
var lineColors = [
  { name: 'Purple', main: '#a78bfa', glow: '#c4b5fd', inner: '#e9e1ff', unlockLevel: 0 },
  { name: 'Cyan', main: '#22d3ee', glow: '#67e8f9', inner: '#cffafe', unlockLevel: 3 },
  { name: 'Rose', main: '#f472b6', glow: '#f9a8d4', inner: '#fce7f3', unlockLevel: 5 },
  { name: 'Amber', main: '#f59e0b', glow: '#fbbf24', inner: '#fef3c7', unlockLevel: 8 },
  { name: 'Emerald', main: '#10b981', glow: '#34d399', inner: '#d1fae5', unlockLevel: 10 },
  { name: 'Red', main: '#ef4444', glow: '#f87171', inner: '#fecaca', unlockLevel: 13 },
  { name: 'White', main: '#e2e8f0', glow: '#f8fafc', inner: '#ffffff', unlockLevel: 15 },
  { name: 'Gold', main: '#eab308', glow: '#facc15', inner: '#fef9c3', unlockLevel: 18 }
];
var selectedLineColor = 0;
var unlockedLineColors = [0]; // indices

// Stats tracking (item 17)
var gameStats = {
  totalCatches: 0,
  totalGames: 0,
  catchesByType: {},
  bestLevel: 0,
  totalTimePlayed: 0, // seconds
  totalTokensEarned: 0
};
var sessionStartTime = 0;

// Tutorial steps (item 16)
var tutorialStepIdx = 0;
var tutorialSteps = [
  { icon: '\u270D', title: 'Draw Lines', text: 'Tap and drag to draw lines.<br>Objects will bounce off your lines!' },
  { icon: '\u2B50', title: 'Safe Zones', text: 'Guide objects into the glowing<br>Safe Zones on the walls to catch them!' },
  { icon: '\u{1F4A5}', title: "Don't Crash!", text: "Don't let objects hit the floor!<br>3 crashes and it's game over." },
  { icon: '\u{1F3AF}', title: 'Earn Rewards', text: 'Every 5 bounces earns Plummet Tokens.<br>Spend them in the shop to upgrade!' }
];

// Time freeze power-up (item 9)
var timeFreezeTimer = 0; // ms remaining
var timeFreezeFlash = 0; // visual flash timer

// Object splitting (item 10)
// handled inline — 30% chance on first bounce for egg

// Countdown timer at game start (item 20)
var countdownTimer = 0; // ms remaining in countdown
var countdownPhase = 0; // 0=not active, 3,2,1 = numbers, -1 = GO

// Camera zoom for level transitions (item 19)
var cameraZoom = 1.0;
var cameraZoomTarget = 1.0;
var cameraZoomTimer = 0;

// Slow-motion on final life (item 17)
var deathSlowmoTimer = 0; // ms remaining
var deathSlowmoActive = false;

// Combo flash tint (item 4 visual)
var comboFlashTimer = 0;
var comboFlashColor = '#fbbf24';

// Level transition fade (smooth screen transition between levels)
var levelTransitionAlpha = 0; // 0 = no overlay, 1 = fully black
var levelTransitionPhase = 0; // 0=inactive, 1=fading out, 2=hold, 3=fading in
var levelTransitionTimer = 0; // ms remaining in current phase

// Catch/crash screen border flash
var catchFlashTimer = 0; // frames remaining for green border flash on catch
var crashFlashTimer = 0; // frames remaining for red border flash on crash

// Encouraging messages between levels
var encouragingMessages = ['Nice work!', 'Keep going!', "You're on fire!", 'Unstoppable!', 'Great reflexes!', 'Level up!', 'Smooth moves!', 'Incredible!'];
var levelMessage = '';
var levelMessageTimer = 0; // frames remaining to display

// Golden zone (item 8 gameplay)
var goldenZone = null; // { side: 'left'|'right', y, h, timer, maxTimer }
var goldenZoneSpawnTimer = 0; // ms until next golden zone spawn

// Same-type combo (item 7)
var lastCatchType = '';
var sameTypeComboCount = 0;

// Line types (item 6)
var lineTypeUpgrades = {
  stickyLines: { level: 0, price: 120, name: 'Sticky Lines', desc: 'Objects slow down 50% on contact', icon: '\uD83E\uDEB4' },
  bouncyLines: { level: 0, price: 100, name: 'Bouncy Lines', desc: '1.3x extra bounce force', icon: '\uD83E\uDE83' },
  curvedLines:  { level: 0, price: 80, name: 'Curved Lines', desc: 'Thicker lines with curve visual', icon: '\u27B0' }
};
var activeLineType = 'normal'; // 'normal', 'stickyLines', 'bouncyLines', 'curvedLines'

// Unlockable background themes (item 12 progression)
var bgThemeShop = [
  { id: 'neonCity', name: 'Neon City', price: 200, colors: { top: '#1a0030', mid: '#3d0066', bot: '#ff00ff' }, desc: 'Purple/Pink neon' },
  { id: 'underwater', name: 'Underwater', price: 200, colors: { top: '#001a33', mid: '#003366', bot: '#008080' }, desc: 'Deep blue/teal' },
  { id: 'autumn', name: 'Autumn', price: 200, colors: { top: '#4a2800', mid: '#8b4513', bot: '#d2691e' }, desc: 'Orange/Brown' }
];
var purchasedBgThemes = [];
var activeBgTheme = null; // null = default, or theme id string

// Milestone rewards (item 14)
var milestoneThresholds = [50, 100, 250, 500, 1000];
var milestoneRewards = [25, 50, 100, 200, 500];
var milestonesCollected = []; // indices of collected milestones

// === NEW FEATURE STATE VARIABLES ===

// 1. Moving safe zones
var safeZonePhase = 0; // sine wave phase

// 2. Gravity flip zones
var gravityFlipZone = null; // { x, y, radius, timer }

// 3. Object weight system — handled inline in checkBounce

// 4. Chain reactions — handled inline in update loop
var mergedObjects = []; // temp array for merge animations

// 5. Line eraser — double-tap detection
var lastTapTime = 0;
var lastTapX = 0;
var lastTapY = 0;

// 6. Wind-up objects — type 'windUp', spawns at level 6+

// 7. Conveyor lines
var conveyorLinesPurchased = false;

// 8. Portal pairs
var portalUpgradeLevel = 0; // max 3
var portalPairs = []; // { entry: {x,y}, exit: {x,y}, color: hue }
var portalPlacingEntry = false; // true = next circle places entry, false = places exit
var portalPendingEntry = null; // {x,y} waiting for exit

// 9. Shrink ray
var shrinkRayTimer = 0; // ms remaining

// 10. Decoy objects — type 'decoy', spawns at level 5+

// 11. Skill tree
var skillTree = {
  speed: [
    { id: 'speed1', name: 'Faster Combo', desc: 'Combo fills 20% faster', cost: 50, owned: false },
    { id: 'speed2', name: 'Wider Zones', desc: 'Safe zones 10% wider', cost: 100, owned: false },
    { id: 'speed3', name: 'Quick Reflex', desc: 'Catch bonus +10%', cost: 200, owned: false }
  ],
  control: [
    { id: 'ctrl1', name: 'Wide Lines', desc: 'Lines 15% wider', cost: 50, owned: false },
    { id: 'ctrl2', name: 'Sticky Lines', desc: 'Objects slow 30% on bounce', cost: 100, owned: false },
    { id: 'ctrl3', name: 'Line Duration', desc: 'Lines last 1s longer', cost: 200, owned: false }
  ],
  luck: [
    { id: 'luck1', name: 'More Power-ups', desc: '2x power-up spawn rate', cost: 50, owned: false },
    { id: 'luck2', name: 'Double Tokens', desc: '15% chance 2x tokens', cost: 100, owned: false },
    { id: 'luck3', name: 'Bonus Life', desc: '+1 life at level 10', cost: 200, owned: false }
  ]
};

// 12. Egg skins
var eggSkins = [
  { id: 'galaxy', name: 'Galaxy Egg', price: 50 },
  { id: 'goldenSkin', name: 'Golden Egg', price: 50 },
  { id: 'neon', name: 'Neon Egg', price: 50 }
];
var purchasedEggSkins = [];
var activeEggSkin = 'default';

// 13. Season pass
var seasonPassXP = 0;
var seasonPassTier = 0;
var seasonPassTiers = [10, 25, 50, 80, 120, 170, 230, 300, 400, 500];
var seasonPassRewards = [
  { type: 'tokens', amount: 25 },
  { type: 'cosmetic', name: 'Cyan Lines', desc: 'Line color unlock' },
  { type: 'tokens', amount: 50 },
  { type: 'cosmetic', name: 'Galaxy Egg', desc: 'Egg skin' },
  { type: 'tokens', amount: 75 },
  { type: 'cosmetic', name: 'Flame Trail', desc: 'Trail effect' },
  { type: 'tokens', amount: 100 },
  { type: 'cosmetic', name: 'Neon Egg', desc: 'Egg skin' },
  { type: 'tokens', amount: 150 },
  { type: 'cosmetic', name: 'Dark Theme', desc: 'Background theme' }
];
var seasonPassClaimed = []; // indices of claimed tiers

// 14. Boss objects — handled in spawnObj and update, boss has hp

// 15. Leaderboard
var leaderboard = []; // { level, catches, tokens, date }

// 16. Slow-motion on catch
var catchSlowmoTimer = 0; // frames remaining
var catchSlowmoFactor = 1.0;

// 17. Screen colour shifts — combo overlay
// handled in draw loop

// 18. Object expressions — handled in draw loop

// 19. Trail customisation
var trailEffects = [
  { id: 'sparkles', name: 'Sparkles', price: 0 },
  { id: 'flames', name: 'Flames', price: 75 },
  { id: 'rainbow', name: 'Rainbow', price: 75 }
];
var purchasedTrails = ['sparkles'];
var activeTrailEffect = 'sparkles';

// 20. Dynamic music — handled in music intervals

// 21. One-hand mode
var oneHandMode = false;

// 22. Auto-pause — already exists via visibilitychange

// 23. Difficulty selector
var gameDifficulty = 'medium'; // 'easy', 'medium', 'hard'
var difficultyMultipliers = {
  easy: { gravity: 0.7, spawnRate: 0.8, maxObjBonus: 0 },
  medium: { gravity: 1.0, spawnRate: 1.0, maxObjBonus: 0 },
  hard: { gravity: 1.3, spawnRate: 1.3, maxObjBonus: 3 }
};

// 24. High-contrast colorblind mode
var highContrastMode = false;

// Animated background elements (item 5)
var bgBirds = []; // for day levels
var bgShootingStars = []; // for night/space levels

// Parallax foreground elements (item 3 visual)
var foregroundElements = [];

// Ambient sound timers (item 23)
var ambientSoundTimer = 0;
var ambientCricketTimer = 0;
var ambientDroneTimer = 0;

// Crowd sound timers (item 22)
var crowdCheerTimer = 0;

// Background theme transition (item 3)
var bgThemeTransition = 0; // 0 to 1 progress
var bgThemePrev = null;
var bgThemeCurrent = null;
var levelStars = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; // stars earned per level (0-3)
var showStars = 0; // how many stars to display
var showStarsTimer = 0; // timer for star display
var levelUpFlash = 0; // screen flash timer for level-up
var nearMissFlash = 0; // screen edge flash timer for near misses
var nearMissX = 0; // x position of near miss for directional flash
var levelUpBanner = 0; // banner display timer
var levelUpBannerLevel = 1; // which level to show on banner
var spawnPauseTimer = 0; // pause spawning at level start (ms)
var bestLevel = 0; // persistent best level
var bestStreak = 0; // persistent best streak
var bestCatches = 0; // persistent best catches
var colorblindMode = false;

// Achievements system
var achievements = [
  { id: 'firstCatch', name: 'First Catch', desc: 'Catch your first object', icon: '\uD83E\uDD5A', check: function() { return totalCatches >= 1; } },
  { id: 'catch10', name: '10 Catches', desc: 'Catch 10 objects', icon: '\uD83C\uDF1F', check: function() { return totalCatches >= 10; } },
  { id: 'catch100', name: '100 Catches', desc: 'Catch 100 objects total', icon: '\uD83C\uDFC6', check: function() { return totalCatches >= 100; } },
  { id: 'level5', name: 'Reach Level 5', desc: 'Make it to level 5', icon: '5\uFE0F\u20E3', check: function() { return level >= 5; } },
  { id: 'level10', name: 'Reach Level 10', desc: 'Make it to level 10', icon: '\uD83D\uDD1F', check: function() { return level >= 10; } },
  { id: 'level20', name: 'Reach Level 20', desc: 'Make it to level 20', icon: '\uD83D\uDC51', check: function() { return level >= 20; } },
  { id: 'streak5', name: '5 Streak', desc: 'Catch 5 in a row', icon: '\uD83D\uDD25', check: function() { return catchStreak >= 5; } },
  { id: 'streak10', name: '10 Streak', desc: 'Catch 10 in a row', icon: '\u26A1', check: function() { return catchStreak >= 10; } },
  { id: 'firstUpgrade', name: 'First Upgrade', desc: 'Buy your first upgrade', icon: '\uD83D\uDED2', check: function() { for(var k in upgrades) { if(upgrades[k].level > 0) return true; } return false; } },
  { id: 'maxUpgrade', name: 'Max Upgrade', desc: 'Max out any upgrade', icon: '\uD83D\uDCAA', check: function() { for(var k in upgrades) { if(upgrades[k].level >= 10) return true; } return false; } },
  { id: 'useShield', name: 'Shield User', desc: 'Use the floor shield', icon: '\uD83D\uDEE1', check: function() { return shieldUsed; } },
  { id: 'goldenEgg', name: 'Golden Egg', desc: 'Catch a golden egg', icon: '\u2728', check: function() { return earnedAchievements.indexOf('goldenEgg') >= 0; } },
  { id: 'level15', name: 'Level Master', desc: 'Reach level 15', icon: '\uD83C\uDF1F', check: function() { return level >= 15; } },
  { id: 'prestige1', name: 'Prestige Player', desc: 'Prestige at least once', icon: '\uD83C\uDFC5', check: function() { return prestigeLevel >= 1; } },
  { id: 'perfectLevel', name: 'Perfect Level', desc: 'Complete a level with zero crashes', icon: '\uD83D\uDC8E', check: function() { return earnedAchievements.indexOf('perfectLevel') >= 0; } },
  { id: 'streak10ach', name: 'Catch Streak 10', desc: 'Catch 10 in a row without crashing', icon: '\u26A1', check: function() { return catchStreak >= 10; } },
  { id: 'century', name: 'Century', desc: 'Reach 100 total catches in a single run', icon: '\uD83D\uDCAF', check: function() { return totalCatches >= 100; } }
];
var earnedAchievements = [];
var achievementPopup = null; // { name, icon, timer }

function checkAchievements() {
  for (var i = 0; i < achievements.length; i++) {
    var a = achievements[i];
    if (earnedAchievements.indexOf(a.id) >= 0) continue;
    if (a.check()) {
      earnedAchievements.push(a.id);
      achievementPopup = { name: a.name, icon: a.icon, timer: 180 };
      try { localStorage.setItem('fluffAchievements', JSON.stringify(earnedAchievements)); } catch(e) {}
    }
  }
}

function loadAchievements() {
  try {
    var raw = localStorage.getItem('fluffAchievements');
    if (raw) earnedAchievements = JSON.parse(raw);
  } catch(e) {}
}

// Level background themes — grouped into thematic ranges with smooth transitions
// Dawn (1-4), Day (5-8), Sunset (9-12), Night (13-16), Space (17-20)
var levelThemes = [
  // Dawn
  { top: '#f0fdfa', mid: '#ccfbf1', bot: '#99f6e4' },  // 1: turquoise
  { top: '#eff6ff', mid: '#bfdbfe', bot: '#93c5fd' },  // 2: blue
  { top: '#fefce8', mid: '#fef08a', bot: '#fde047' },  // 3: yellow
  { top: '#fdf2f8', mid: '#fbcfe8', bot: '#f9a8d4' },  // 4: pink
  // Day
  { top: '#f0fdf4', mid: '#bbf7d0', bot: '#86efac' },  // 5: green
  { top: '#fff7ed', mid: '#fed7aa', bot: '#fdba74' },  // 6: orange
  { top: '#ecfeff', mid: '#a5f3fc', bot: '#67e8f9' },  // 7: cyan
  { top: '#e0f2fe', mid: '#7dd3fc', bot: '#38bdf8' },  // 8: sky blue
  // Sunset
  { top: '#fef2f2', mid: '#fca5a5', bot: '#f87171' },  // 9: red
  { top: '#fff7ed', mid: '#fb923c', bot: '#ea580c' },  // 10: burnt orange
  { top: '#ffe4e6', mid: '#fb7185', bot: '#e11d48' },  // 11: rose
  { top: '#faf5ff', mid: '#d8b4fe', bot: '#c084fc' },  // 12: purple sunset
  // Night
  { top: '#1e1b4b', mid: '#312e81', bot: '#4338ca' },  // 13: midnight
  { top: '#0f172a', mid: '#1e293b', bot: '#334155' },  // 14: dark slate
  { top: '#0c0a1a', mid: '#1a1040', bot: '#2d1b69' },  // 15: deep night
  { top: '#0e1628', mid: '#162544', bot: '#1e3a5f' },  // 16: dark ocean
  // Space
  { top: '#030712', mid: '#0a0520', bot: '#1a0a2e' },  // 17: void
  { top: '#050510', mid: '#0d0828', bot: '#1a0f40' },  // 18: nebula
  { top: '#000005', mid: '#08051a', bot: '#150a30' },  // 19: deep space
  { top: '#000000', mid: '#050515', bot: '#0a0a28' },  // 20: black hole
];

// Demo objects for start screen
var demoObjects = [];
var demoParticles = [];

// Sound system (Web Audio API)
var audioCtx = null;
var muted = false;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

var musicVol = 1.0;
var sfxVol = 1.0;

function toggleMute() {
  muted = !muted;
  document.getElementById('muteBtn').textContent = muted ? '\uD83D\uDD07' : '\uD83D\uDD0A';
}

function setMusicVol(v) { musicVol = v / 100; }
function setSfxVol(v) { sfxVol = v / 100; }

function openSettings() {
  initAudio();
  document.getElementById('statBestLevel').textContent = bestLevel || '-';
  document.getElementById('statBestStreak').textContent = bestStreak || '-';
  document.getElementById('statBestCatches').textContent = bestCatches || '-';
  document.getElementById('settingsScreen').classList.add('show');
}

function closeSettings() {
  document.getElementById('settingsScreen').classList.remove('show');
}

function toggleColorblind(on) {
  colorblindMode = on;
  try { localStorage.setItem('fluffColorblind', on ? '1' : '0'); } catch(e) {}
}

function openAchievements() {
  var list = document.getElementById('achievementsList');
  list.innerHTML = '';
  for (var i = 0; i < achievements.length; i++) {
    var a = achievements[i];
    var earned = earnedAchievements.indexOf(a.id) >= 0;
    var div = document.createElement('div');
    div.style.cssText = 'width:90px; height:90px; border-radius:14px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; font-size:11px; text-align:center; border:2px solid ' + (earned ? '#fbbf24' : 'rgba(255,255,255,0.15)') + '; background:' + (earned ? 'rgba(251,191,36,0.1)' : 'rgba(255,255,255,0.03)') + '; opacity:' + (earned ? '1' : '0.4') + ';';
    div.innerHTML = '<span style="font-size:28px;">' + (earned ? a.icon : '\uD83D\uDD12') + '</span><span>' + a.name + '</span>';
    list.appendChild(div);
  }
  document.getElementById('achievementsScreen').style.display = 'flex';
}

function closeAchievements() {
  document.getElementById('achievementsScreen').style.display = 'none';
}

function confirmReset() {
  if (confirm('Reset ALL progress? Tokens, upgrades, stats, prestige, achievements, milestones, and themes will be lost.')) {
    localStorage.removeItem('fluffSave');
    localStorage.removeItem('fluffTutorialSeen');
    localStorage.removeItem('fluffAchievements');
    localStorage.removeItem('fluffStats');
    localStorage.removeItem('fluffColorblind');
    localStorage.removeItem('fluffHighContrast');
    localStorage.removeItem('fluffOneHand');
    location.reload();
  }
}

function playTone(freq, duration, type, vol, detune, isMusic) {
  try {
    if (!audioCtx || muted) return;
    var volMult = isMusic ? musicVol : sfxVol;
    var osc = audioCtx.createOscillator();
    var gain = audioCtx.createGain();
    osc.type = type || 'sine';
    osc.frequency.value = freq;
    if (detune) osc.detune.value = detune;
    gain.gain.setValueAtTime((vol || 0.15) * volMult, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  } catch(e) {}
}

function sfxBounce(objType) {
  if (objType === 'bouncyBall') {
    // Boing
    playTone(300, 0.15, 'sine', 0.10);
    playTone(600, 0.08, 'sine', 0.06);
  } else {
    playTone(520, 0.12, 'sine', 0.12);
    playTone(780, 0.08, 'sine', 0.06);
  }
}

function sfxCatch(objType) {
  if (objType === 'bouncyBall') {
    // Boing catch
    playTone(400, 0.1, 'sine', 0.12);
    setTimeout(function() { playTone(600, 0.08, 'sine', 0.10); }, 50);
    setTimeout(function() { playTone(800, 0.1, 'sine', 0.08); }, 100);
  } else {
    // Egg soft pop
    playTone(660, 0.08, 'sine', 0.10);
    setTimeout(function() { playTone(880, 0.08, 'sine', 0.10); }, 60);
    setTimeout(function() { playTone(1100, 0.12, 'sine', 0.08); }, 120);
  }
}

// Magnet hum
function sfxMagnetPickup() {
  playTone(220, 0.2, 'sine', 0.08);
  setTimeout(function() { playTone(330, 0.15, 'sine', 0.08); }, 60);
  setTimeout(function() { playTone(440, 0.2, 'sine', 0.06); }, 120);
}

function sfxCrash() {
  playTone(120, 0.3, 'sawtooth', 0.12);
  playTone(80, 0.4, 'square', 0.08);
}

function sfxLevelUp() {
  playTone(523, 0.12, 'sine', 0.12);
  setTimeout(function() { playTone(659, 0.12, 'sine', 0.12); }, 100);
  setTimeout(function() { playTone(784, 0.12, 'sine', 0.12); }, 200);
  setTimeout(function() { playTone(1047, 0.25, 'sine', 0.14); }, 300);
}

var bgMusicInterval = null;
var bgBassInterval = null;
var bgArpInterval = null;
var bgPadInterval = null;
var musicGain = 1.0; // fades toward 0 when paused, 1 when playing
var musicMelodyTimer = null; // setTimeout-based for dynamic tempo
function startBgMusic() {
  if (bgMusicInterval || musicMelodyTimer) return;
  // Dark minor key melodies — alternate every 16 notes
  var melody1 = [165, 196, 220, 196, 165, 147, 131, 147, 175, 208, 233, 208, 175, 156, 139, 156];
  var melody2 = [147, 175, 196, 220, 196, 175, 165, 147, 156, 185, 208, 220, 208, 185, 165, 156];
  var noteIdx = 0;
  var melodySwitch = 0;
  function melodyTick() {
    // Fade musicGain toward target
    var targetGain = (muted || !running || paused) ? 0 : 1;
    musicGain += (targetGain - musicGain) * 0.08;
    if (musicGain >= 0.005) {
      var melody = (melodySwitch % 2 === 0) ? melody1 : melody2;
      // Pitch shift when combo multiplier is 2x+ (item 21)
      var pitchShift = comboMultiplier >= 2 ? 1 + (comboMultiplier - 1) * 0.05 : 1;
      // Item 20: Dynamic music — adjust based on active object count
      var activeObjCount = 0;
      for (var mi = 0; mi < objects.length; mi++) { if (objects[mi].alive) activeObjCount++; }
      var urgencyVol = activeObjCount >= 7 ? 1.3 : activeObjCount >= 4 ? 1.1 : 1.0;
      playTone(melody[noteIdx] * pitchShift, 0.25, 'triangle', 0.04 * musicGain * urgencyVol, 0, true);
      // Higher octave echo
      playTone(melody[noteIdx] * 2 * pitchShift, 0.15, 'sine', 0.015 * musicGain * urgencyVol, 0, true);
      // Urgency oscillator at 7+ objects
      if (activeObjCount >= 7) {
        playTone(melody[noteIdx] * pitchShift * 0.5, 0.1, 'sawtooth', 0.01 * musicGain, 0, true);
      }
      noteIdx = (noteIdx + 1) % melody.length;
      if (noteIdx === 0) melodySwitch++;
    }
    // Item 20: Dynamic tempo — faster when more objects on screen
    // Base: 320ms, 4-6 objects: 260ms, 7+: 210ms
    var activeCount = 0;
    for (var ti = 0; ti < objects.length; ti++) { if (objects[ti].alive) activeCount++; }
    var tempoMs = activeCount >= 7 ? 210 : activeCount >= 4 ? 260 : 320;
    musicMelodyTimer = setTimeout(melodyTick, tempoMs);
  }
  musicMelodyTimer = setTimeout(melodyTick, 320);
  // Deep rumbling bass drone — alternate pattern every 32 beats
  var bassIdx = 0;
  var bassPattern1 = [55, 55, 55, 55];
  var bassPattern2 = [55, 65, 55, 49];
  bgBassInterval = setInterval(function() {
    var targetGain = (muted || !running || paused) ? 0 : 1;
    musicGain += (targetGain - musicGain) * 0.08;
    if (musicGain < 0.005) return;
    var bass = (Math.floor(bassIdx / 4) % 2 === 0) ? bassPattern1 : bassPattern2;
    var bn = bass[bassIdx % bass.length];
    playTone(bn, 0.6, 'sawtooth', 0.025 * musicGain, 0, true);
    playTone(bn * 1.5, 0.4, 'triangle', 0.02 * musicGain, 0, true);
    bassIdx++;
  }, 1280);

  // Layer 2: Arpeggio (level 5+) — fast shimmering notes
  var arpNotes = [330, 392, 440, 523, 440, 392];
  var arpIdx = 0;
  bgArpInterval = setInterval(function() {
    if (level < 5) return;
    var targetGain = (muted || !running || paused) ? 0 : 1;
    musicGain += (targetGain - musicGain) * 0.08;
    if (musicGain < 0.005) return;
    var intensity = Math.min(1, (level - 5) / 10);
    playTone(arpNotes[arpIdx], 0.1, 'sine', 0.02 * musicGain * intensity, 0, true);
    arpIdx = (arpIdx + 1) % arpNotes.length;
  }, 160);

  // Layer 3: Pad (level 10+) — sustained ambient tones
  bgPadInterval = setInterval(function() {
    if (level < 10) return;
    var targetGain = (muted || !running || paused) ? 0 : 1;
    musicGain += (targetGain - musicGain) * 0.08;
    if (musicGain < 0.005) return;
    var intensity = Math.min(1, (level - 10) / 10);
    playTone(110, 0.8, 'sine', 0.015 * musicGain * intensity, 0, true);
    playTone(165, 0.6, 'sine', 0.01 * musicGain * intensity, 0, true);
    if (level >= 15) {
      playTone(220, 0.5, 'triangle', 0.008 * musicGain * intensity, 0, true);
    }
  }, 2000);
}

function sfxPowerup() {
  playTone(880, 0.08, 'sine', 0.10);
  setTimeout(function() { playTone(1100, 0.08, 'sine', 0.10); }, 50);
  setTimeout(function() { playTone(1320, 0.08, 'sine', 0.10); }, 100);
  setTimeout(function() { playTone(1760, 0.15, 'sine', 0.08); }, 150);
}

function sfxClick() {
  playTone(600, 0.05, 'sine', 0.06);
}

// Safe zone catch chime — ascending 3 notes, higher pitch
function sfxCatchZone() {
  playTone(880, 0.1, 'sine', 0.10);
  setTimeout(function() { playTone(1100, 0.1, 'sine', 0.10); }, 60);
  setTimeout(function() { playTone(1400, 0.15, 'sine', 0.10); }, 120);
}

// Line drawing swish sound
function sfxLine() {
  playTone(1200, 0.06, 'sine', 0.06);
}

// Game Over sting — descending minor chord
function sfxGameOver() {
  playTone(440, 0.3, 'sawtooth', 0.10);
  setTimeout(function() { playTone(349, 0.3, 'sawtooth', 0.10); }, 150);
  setTimeout(function() { playTone(294, 0.3, 'sawtooth', 0.10); }, 300);
  setTimeout(function() { playTone(220, 0.4, 'sawtooth', 0.10); }, 450);
}

// Combo ready sound — quick rising tone at combo 3
function sfxComboReady() {
  playTone(600, 0.08, 'sine', 0.08);
  setTimeout(function() { playTone(800, 0.08, 'sine', 0.08); }, 60);
  setTimeout(function() { playTone(1000, 0.1, 'sine', 0.06); }, 120);
}

// Distinct power-up pickup sounds
function sfxShieldPickup() {
  playTone(220, 0.2, 'sine', 0.10);
  playTone(165, 0.3, 'triangle', 0.08);
}
function sfxSlowmoPickup() {
  playTone(600, 0.15, 'sine', 0.08);
  setTimeout(function() { playTone(400, 0.15, 'sine', 0.08); }, 80);
  setTimeout(function() { playTone(500, 0.2, 'sine', 0.06); }, 160);
}
function sfxDoublePickup() {
  playTone(1000, 0.06, 'sine', 0.08);
  setTimeout(function() { playTone(1200, 0.06, 'sine', 0.08); }, 50);
  setTimeout(function() { playTone(1400, 0.06, 'sine', 0.08); }, 100);
  setTimeout(function() { playTone(1600, 0.08, 'sine', 0.06); }, 150);
}

// Near miss sound — subtle bzzt
function sfxNearMiss() {
  playTone(150, 0.08, 'square', 0.05);
  playTone(100, 0.1, 'sawtooth', 0.03);
}

// Escalating catch ding — pitch rises with streak
function sfxCatchDing() {
  var freq = 400 + catchStreak * 40;
  freq = Math.min(freq, 1200); // cap at 1200Hz
  playTone(freq, 0.1, 'sine', 0.12);
}

function stopBgMusic() {
  if (musicMelodyTimer) { clearTimeout(musicMelodyTimer); musicMelodyTimer = null; }
  if (bgMusicInterval) { clearInterval(bgMusicInterval); bgMusicInterval = null; }
  if (bgBassInterval) { clearInterval(bgBassInterval); bgBassInterval = null; }
  if (bgArpInterval) { clearInterval(bgArpInterval); bgArpInterval = null; }
  if (bgPadInterval) { clearInterval(bgPadInterval); bgPadInterval = null; }
}

function sfxBomb() {
  playTone(60, 0.5, 'sawtooth', 0.15);
  playTone(40, 0.6, 'square', 0.10);
  playTone(200, 0.15, 'square', 0.08);
}

// Consistent glow values
var GLOW_SM = 6, GLOW_MD = 12, GLOW_LG = 18;

var BASE_GRAVITY = 0.035;
var BASE_BOUNCE = 1.1;
var GRAVITY = BASE_GRAVITY;
var BOUNCE = BASE_BOUNCE;

// Unified upgrade system
var upgrades = {
  bounceHigher: { level: 0, price: 75 },
  widerLines:   { level: 0, price: 75 },
  shieldFloor:  { level: 0, price: 50 },
  widerZones:   { level: 0, price: 100 },
  slowerMeteors: { level: 0, price: 80 },
  fasterCombo:  { level: 0, price: 90 },
};
var shieldTimeLeft = 0; // milliseconds remaining on floor shield
var shieldUsed = false; // whether the floor shield has been activated this game
var shieldActive = false; // whether the shield is currently running

function applyUpgrades() {
  GRAVITY = BASE_GRAVITY;
  BOUNCE = BASE_BOUNCE + upgrades.bounceHigher.level * 0.05;
  maxLives = 3;
  // Skill tree: luck3 — bonus life at level 10
  if (skillTree.luck[2].owned && level >= 10) maxLives = 4;
}

function buyUpgrade(name) {
  sfxClick();
  var u = upgrades[name];
  if (u.level >= 10) {
    showWarning(name + ' is already maxed out!');
    return;
  }
  if (fluffTokens >= u.price) {
    fluffTokens -= u.price;
    u.level++;
    var priceInc = 75;
    if (name === 'shieldFloor') priceInc = 50;
    else if (name === 'widerZones') priceInc = 100;
    else if (name === 'slowerMeteors') priceInc = 80;
    else if (name === 'fasterCombo') priceInc = 90;
    u.price += priceInc;
    applyUpgrades();
    document.getElementById(name + 'Btn').classList.add('active');
    if (name === 'shieldFloor') {
      document.getElementById(name + 'Lv').textContent = (u.level * 2) + 's';
    } else {
      document.getElementById(name + 'Lv').textContent = 'Lv:' + u.level + '/10';
    }
    document.getElementById(name + 'Price').textContent = u.level < 10 ? '(' + u.price + ')' : '(MAX)';
    updateHUD();
    saveProgress();
  } else {
    var needed = u.price - fluffTokens;
    showWarning('You need ' + needed + ' more Plummet Tokens!');
  }
}
var warningTimer = null;
function showWarning(msg) {
  var el = document.getElementById('tokenWarning');
  el.textContent = msg;
  el.style.transition = 'none';
  el.style.opacity = '1';
  if (warningTimer) clearTimeout(warningTimer);
  warningTimer = setTimeout(function() {
    el.style.transition = 'opacity 1s ease';
    el.style.opacity = '0';
  }, 5000);
}

// Save/Load progress
function saveProgress() {
  var data = {
    fluffTokens: fluffTokens,
    upgrades: {},
    levelStars: levelStars,
    bestLevel: bestLevel,
    bestStreak: bestStreak,
    bestCatches: bestCatches,
    prestigeLevel: prestigeLevel,
    prestigeMultiplier: prestigeMultiplier,
    selectedLineColor: selectedLineColor,
    unlockedLineColors: unlockedLineColors,
    gameStats: gameStats,
    lineTypeUpgrades: {},
    activeLineType: activeLineType,
    purchasedBgThemes: purchasedBgThemes,
    activeBgTheme: activeBgTheme,
    milestonesCollected: milestonesCollected,
    skillTree: { speed: [], control: [], luck: [] },
    purchasedEggSkins: purchasedEggSkins,
    activeEggSkin: activeEggSkin,
    purchasedTrails: purchasedTrails,
    activeTrailEffect: activeTrailEffect,
    seasonPassXP: seasonPassXP,
    seasonPassTier: seasonPassTier,
    seasonPassClaimed: seasonPassClaimed,
    leaderboard: leaderboard,
    conveyorLinesPurchased: conveyorLinesPurchased,
    portalUpgradeLevel: portalUpgradeLevel,
    oneHandMode: oneHandMode,
    highContrastMode: highContrastMode,
    gameDifficulty: gameDifficulty
  };
  // Save skill tree state
  for (var path in skillTree) {
    data.skillTree[path] = [];
    for (var ni = 0; ni < skillTree[path].length; ni++) {
      data.skillTree[path].push(skillTree[path][ni].owned);
    }
  }
  for (var k in upgrades) {
    data.upgrades[k] = { level: upgrades[k].level, price: upgrades[k].price };
  }
  for (var k in lineTypeUpgrades) {
    data.lineTypeUpgrades[k] = { level: lineTypeUpgrades[k].level, price: lineTypeUpgrades[k].price };
  }
  try {
    localStorage.setItem('fluffSave', JSON.stringify(data));
  } catch(e) {
    // localStorage may be full or unavailable
  }
}

function loadProgress() {
  try {
    var raw = localStorage.getItem('fluffSave');
    if (!raw) return;
    var data = JSON.parse(raw);
    fluffTokens = data.fluffTokens || 0;
    if (data.levelStars) levelStars = data.levelStars;
    if (data.bestLevel) bestLevel = data.bestLevel;
    if (data.bestStreak) bestStreak = data.bestStreak;
    if (data.bestCatches) bestCatches = data.bestCatches;
    if (data.prestigeLevel !== undefined) prestigeLevel = data.prestigeLevel;
    if (data.prestigeMultiplier !== undefined) prestigeMultiplier = data.prestigeMultiplier;
    if (data.selectedLineColor !== undefined) selectedLineColor = data.selectedLineColor;
    if (data.unlockedLineColors) unlockedLineColors = data.unlockedLineColors;
    if (data.gameStats) {
      for (var sk in data.gameStats) {
        gameStats[sk] = data.gameStats[sk];
      }
    }
    if (data.upgrades) {
      for (var k in data.upgrades) {
        if (upgrades[k]) {
          upgrades[k].level = data.upgrades[k].level;
          upgrades[k].price = data.upgrades[k].price;
        }
      }
    }
    if (data.lineTypeUpgrades) {
      for (var k in data.lineTypeUpgrades) {
        if (lineTypeUpgrades[k]) {
          lineTypeUpgrades[k].level = data.lineTypeUpgrades[k].level;
          lineTypeUpgrades[k].price = data.lineTypeUpgrades[k].price;
        }
      }
    }
    if (data.activeLineType) activeLineType = data.activeLineType;
    if (data.purchasedBgThemes) purchasedBgThemes = data.purchasedBgThemes;
    if (data.activeBgTheme !== undefined) activeBgTheme = data.activeBgTheme;
    if (data.milestonesCollected) milestonesCollected = data.milestonesCollected;
    // Load new feature data
    if (data.skillTree) {
      for (var path in data.skillTree) {
        if (skillTree[path]) {
          for (var ni = 0; ni < data.skillTree[path].length && ni < skillTree[path].length; ni++) {
            skillTree[path][ni].owned = data.skillTree[path][ni];
          }
        }
      }
    }
    if (data.purchasedEggSkins) purchasedEggSkins = data.purchasedEggSkins;
    if (data.activeEggSkin) activeEggSkin = data.activeEggSkin;
    // Migrate old 'golden_skin' id to 'goldenSkin'
    for (var esi = 0; esi < purchasedEggSkins.length; esi++) {
      if (purchasedEggSkins[esi] === 'golden_skin') purchasedEggSkins[esi] = 'goldenSkin';
    }
    if (activeEggSkin === 'golden_skin') activeEggSkin = 'goldenSkin';
    if (data.purchasedTrails) purchasedTrails = data.purchasedTrails;
    if (data.activeTrailEffect) activeTrailEffect = data.activeTrailEffect;
    if (data.seasonPassXP !== undefined) seasonPassXP = data.seasonPassXP;
    if (data.seasonPassTier !== undefined) seasonPassTier = data.seasonPassTier;
    if (data.seasonPassClaimed) seasonPassClaimed = data.seasonPassClaimed;
    if (data.leaderboard) leaderboard = data.leaderboard;
    if (data.conveyorLinesPurchased) conveyorLinesPurchased = data.conveyorLinesPurchased;
    if (data.portalUpgradeLevel !== undefined) portalUpgradeLevel = data.portalUpgradeLevel;
    if (data.oneHandMode !== undefined) oneHandMode = data.oneHandMode;
    if (data.highContrastMode !== undefined) highContrastMode = data.highContrastMode;
    if (data.gameDifficulty) gameDifficulty = data.gameDifficulty;
    applyUpgrades();
    lives = maxLives;
    // Update UI to reflect loaded state
    for (var k in upgrades) {
      var u = upgrades[k];
      if (u.level > 0) document.getElementById(k + 'Btn').classList.add('active');
      if (k === 'shieldFloor') {
        document.getElementById(k + 'Lv').textContent = (u.level * 2) + 's';
      } else {
        document.getElementById(k + 'Lv').textContent = 'Lv:' + u.level + '/10';
      }
      document.getElementById(k + 'Price').textContent = u.level < 10 ? '(' + u.price + ')' : '(MAX)';
    }
    updateLineTypeShopUI();
    updateBgThemeShopUI();
    updateSettingsSelectors();
    updateHUD();
  } catch(e) {}
}

var LINE_LIFE = 2000;

// Drawing state
var dragging = false;
var dragX1 = 0, dragY1 = 0, dragX2 = 0, dragY2 = 0;

function getXY(e) {
  var r = canvas.getBoundingClientRect();
  if (e.touches) {
    var t = e.touches[0] || e.changedTouches[0];
    return [t.clientX - r.left, t.clientY - r.top];
  }
  return [e.clientX - r.left, e.clientY - r.top];
}

// Track draw path for circle detection
var drawPath = [];

canvas.onmousedown = function(e) {
  if (!running) return;
  var p = getXY(e);
  // Item 5: Line eraser — double-tap detection
  var now = Date.now();
  if (now - lastTapTime < 300 && Math.abs(p[0] - lastTapX) < 30 && Math.abs(p[1] - lastTapY) < 30) {
    eraseLine(p[0], p[1]);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;
  lastTapX = p[0]; lastTapY = p[1];
  // Item 21: One-hand mode — place pre-angled bounce pad
  if (oneHandMode) {
    placeOneHandPad(p[0], p[1]);
    return;
  }
  dragX1 = p[0]; dragY1 = p[1];
  dragX2 = p[0]; dragY2 = p[1];
  dragging = true;
  drawPath = [{ x: p[0], y: p[1] }];
};
canvas.onmousemove = function(e) {
  if (!dragging) return;
  var p = getXY(e);
  dragX2 = p[0]; dragY2 = p[1];
  drawPath.push({ x: p[0], y: p[1] });
};
canvas.onmouseup = function(e) {
  if (!dragging) return;
  var p = getXY(e);
  drawPath.push({ x: p[0], y: p[1] });
  // Check if this is a circle gesture
  if (checkCircleGesture(dragX1, dragY1, p[0], p[1], drawPath)) {
    dragging = false;
    drawPath = [];
    return;
  }
  addLine(dragX1, dragY1, p[0], p[1]);
  dragging = false;
  drawPath = [];
};

canvas.ontouchstart = function(e) {
  e.preventDefault();
  if (!running) return;
  var p = getXY(e);
  // Item 5: Line eraser — double-tap detection
  var now = Date.now();
  if (now - lastTapTime < 300 && Math.abs(p[0] - lastTapX) < 30 && Math.abs(p[1] - lastTapY) < 30) {
    eraseLine(p[0], p[1]);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;
  lastTapX = p[0]; lastTapY = p[1];
  // Item 21: One-hand mode
  if (oneHandMode) {
    placeOneHandPad(p[0], p[1]);
    return;
  }
  dragX1 = p[0]; dragY1 = p[1];
  dragX2 = p[0]; dragY2 = p[1];
  dragging = true;
  drawPath = [{ x: p[0], y: p[1] }];
};
canvas.ontouchmove = function(e) {
  e.preventDefault();
  if (!dragging) return;
  var p = getXY(e);
  dragX2 = p[0]; dragY2 = p[1];
  drawPath.push({ x: p[0], y: p[1] });
};
canvas.ontouchend = function(e) {
  e.preventDefault();
  if (!dragging) return;
  var p = getXY(e);
  drawPath.push({ x: p[0], y: p[1] });
  if (checkCircleGesture(dragX1, dragY1, p[0], p[1], drawPath)) {
    dragging = false;
    drawPath = [];
    return;
  }
  addLine(dragX1, dragY1, p[0], p[1]);
  dragging = false;
  drawPath = [];
};

// Item 5: Line eraser
function eraseLine(x, y) {
  var bestIdx = -1;
  var bestDist = 50;
  for (var i = 0; i < lines.length; i++) {
    var L = lines[i];
    if (L.done) continue;
    // Distance from point to line segment
    var lx = L.x2 - L.x1, ly = L.y2 - L.y1;
    var len = Math.sqrt(lx * lx + ly * ly);
    if (len < 1) continue;
    var t = Math.max(0, Math.min(1, ((x - L.x1) * lx + (y - L.y1) * ly) / (len * len)));
    var px = L.x1 + t * lx, py = L.y1 + t * ly;
    var d = Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  if (bestIdx >= 0) {
    var eL = lines[bestIdx];
    // Dissolve particles
    for (var ep = 0; ep < 15; ep++) {
      var et = Math.random();
      var epx = eL.x1 + (eL.x2 - eL.x1) * et;
      var epy = eL.y1 + (eL.y2 - eL.y1) * et;
      particles.push({
        x: epx, y: epy,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.5) * 3 - 1,
        life: 0.6,
        color: lineColors[selectedLineColor].main,
        size: 2 + Math.random() * 3,
        shape: 'circle',
        rot: 0, rotSpeed: 0
      });
    }
    eL.done = true;
    sfxLineErase();
  }
}

// Item 21: One-hand mode — place bounce pad angled toward nearest safe zone
function placeOneHandPad(x, y) {
  var zR = getZone(); var zL = getZoneLeft();
  var rCX = CW - WALL_W / 2, rCY = zR.y + zR.h / 2;
  var lCX = WALL_W / 2, lCY = zL.y + zL.h / 2;
  var rDist = Math.sqrt((x - rCX) * (x - rCX) + (y - rCY) * (y - rCY));
  var lDist = Math.sqrt((x - lCX) * (x - lCX) + (y - lCY) * (y - lCY));
  var tX = rDist < lDist ? rCX : lCX;
  var tY = rDist < lDist ? rCY : lCY;
  var angle = Math.atan2(tY - y, tX - x);
  var padLen = 40;
  // Place a short line perpendicular to the direction (acts as a bounce surface)
  var perpAngle = angle + Math.PI / 2;
  var x1 = x + Math.cos(perpAngle) * padLen / 2;
  var y1 = y + Math.sin(perpAngle) * padLen / 2;
  var x2 = x - Math.cos(perpAngle) * padLen / 2;
  var y2 = y - Math.sin(perpAngle) * padLen / 2;
  addLine(x1, y1, x2, y2);
}

// Item 2: Gravity flip zone + Item 8: Portal pairs — circle gesture detection
function checkCircleGesture(x1, y1, x2, y2, path) {
  var dx = x2 - x1, dy = y2 - y1;
  var endDist = Math.sqrt(dx * dx + dy * dy);
  if (endDist > 30 || path.length < 8) return false;
  // Calculate area using shoelace formula
  var area = 0;
  for (var i = 0; i < path.length - 1; i++) {
    area += path[i].x * path[i + 1].y - path[i + 1].x * path[i].y;
  }
  area = Math.abs(area) / 2;
  if (area < 500) return false; // too small
  // Calculate center
  var cx = 0, cy = 0;
  for (var i = 0; i < path.length; i++) { cx += path[i].x; cy += path[i].y; }
  cx /= path.length; cy /= path.length;
  var radius = Math.sqrt(area / Math.PI);

  // Item 8: Portal pairs — if upgrade owned and pairs available
  if (portalUpgradeLevel > 0) {
    var activePairsCount = portalPairs.length;
    if (portalPendingEntry) {
      // Place exit portal
      portalPairs.push({ entry: portalPendingEntry, exit: { x: cx, y: cy }, color: (activePairsCount * 60 + 200) % 360 });
      burst(cx, cy, '#fb923c', 12);
      floatText('Exit Portal!', cx, cy - 25, '#fb923c', 18);
      sfxPortalExit();
      portalPendingEntry = null;
      return true;
    } else if (activePairsCount < portalUpgradeLevel) {
      // Place entry portal
      portalPendingEntry = { x: cx, y: cy };
      burst(cx, cy, '#60a5fa', 12);
      floatText('Entry Portal - draw exit!', cx, cy - 25, '#60a5fa', 16);
      sfxPortalEnter();
      return true;
    }
  }

  // Item 2: Gravity flip zone
  if (!gravityFlipZone) {
    gravityFlipZone = { x: cx, y: cy, radius: Math.max(30, Math.min(80, radius)), timer: 3000 };
    sfxGravityFlip();
    burst(cx, cy, '#a78bfa', 15);
    floatText('Gravity Flip!', cx, cy - 25, '#a78bfa', 18);
    return true;
  }
  return false;
}

function addLine(x1, y1, x2, y2) {
  var dx = x2 - x1, dy = y2 - y1;
  var len = Math.sqrt(dx * dx + dy * dy);
  if (len > 15) {
    lines.push({ x1: x1, y1: y1, x2: x2, y2: y2, born: Date.now() });
    sfxLine();
    // Line creation particles (item 38)
    for (var lp = 0; lp < 8; lp++) {
      var lt = Math.random();
      var lpx = x1 + (x2 - x1) * lt;
      var lpy = y1 + (y2 - y1) * lt;
      particles.push({
        x: lpx, y: lpy,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2 - 1,
        life: 0.6,
        color: [lineColors[selectedLineColor].glow, lineColors[selectedLineColor].main, lineColors[selectedLineColor].inner][Math.floor(Math.random() * 3)],
        size: 2 + Math.random() * 2,
        shape: 'circle',
        rot: 0,
        rotSpeed: 0
      });
    }
  }
}

// Safe zones - shrink with level
var WALL_W = 12;
function getZoneHeight() {
  var full = CH - WALL_W;
  var shrink = Math.max(0.18, 1 - (level - 1) * 0.045);
  // Additional per-level shrink for later difficulty scaling
  var levelShrink = Math.max(0.7, 1 - level * 0.015);
  // Wider zones upgrade adds 3% per level
  var zoneBonus = 1 + upgrades.widerZones.level * 0.03;
  // Skill tree: speed2 — wider zones
  if (skillTree.speed[1].owned) zoneBonus += 0.10;
  return Math.floor(full * shrink * levelShrink * zoneBonus);
}
function getZone() {
  var h = getZoneHeight();
  // Item 1: Moving safe zones — subtle sine wave movement
  var moveRange = h * 0.175; // 17.5% of zone height
  var yOffset = Math.sin(safeZonePhase * 0.7) * moveRange;
  var baseY = Math.floor(CH / 2 - h / 2);
  var y = Math.max(WALL_W, Math.min(CH - WALL_W - h, baseY + yOffset));
  return { x: CW - WALL_W, y: y, w: WALL_W, h: h };
}
function getZoneLeft() {
  var h = getZoneHeight();
  // Item 1: Moving safe zones — offset phase from right zone
  var moveRange = h * 0.175;
  var yOffset = Math.sin(safeZonePhase * 0.7 + Math.PI * 0.5) * moveRange;
  var baseY = Math.floor(CH / 2 - h / 2);
  var y = Math.max(WALL_W, Math.min(CH - WALL_W - h, baseY + yOffset));
  return { x: 0, y: y, w: WALL_W, h: h };
}

// Spawn
function spawnObj() {
  var rng = Math.random;
  var types = ['egg'];
  // New types by level
  if (level >= 4) types.push('bouncyBall');
  // Meteors start appearing at level 5 — steeper increase after level 10
  var meteorChance = 0.10 + (level - 4) * 0.015;
  if (level > 10) meteorChance += (level - 10) * 0.025; // extra steep after level 10
  if (level >= 5 && rng() < meteorChance) {
    types.push('meteor');
  }
  // Golden egg - rare (8% chance)
  var golden = false;
  if (rng() < 0.08) {
    golden = true;
  }
  // Wind-up objects from level 6+ (item 6 new mechanics)
  if (level >= 6) types.push('windUp');
  // Decoy objects from level 5+ with 15% chance (item 10 new mechanics)
  var isDecoy = false;
  if (level >= 5 && rng() < 0.15 && !golden) {
    isDecoy = true;
  }
  // Power-up drop (~6% chance, level 3+, doubled with skill tree luck1)
  var powerup = null;
  var puChance = 0.06;
  if (skillTree.luck[0].owned) puChance *= 2;
  if (!golden && !isDecoy && level >= 3 && rng() < puChance) {
    var puTypes = ['shield', 'doubleTokens', 'magnet', 'shrinkRay'];
    powerup = puTypes[Math.floor(rng() * puTypes.length)];
  }
  var type = powerup ? 'powerup' : types[Math.floor(rng() * types.length)];
  if (isDecoy) type = 'decoy';
  if (golden) type = 'egg';
  var isMeteor = (type === 'meteor');
  var isBouncyBall = (type === 'bouncyBall');
  var fragile = 0;
  var slowMult = 1;
  // Use preview position if ready, otherwise random
  var spawnX;
  if (nextSpawnReady) {
    spawnX = nextSpawnX;
    nextSpawnReady = false;
  } else {
    spawnX = WALL_W + 30 + rng() * (CW - WALL_W * 2 - 80);
  }
  // Prepare next spawn preview
  nextSpawnX = WALL_W + 30 + rng() * (CW - WALL_W * 2 - 80);
  nextSpawnReady = true;
  var initVY = isMeteor ? 0.5 : 0.2 * slowMult;
  // Meteors slower with upgrade
  if (isMeteor) initVY *= Math.max(0.5, 1 - upgrades.slowerMeteors.level * 0.05);
  // Boss object every 10 levels (item 14 new)
  var isBoss = false;
  if (level % 10 === 0 && level > 0 && type !== 'meteor' && type !== 'powerup' && !isDecoy) {
    // Only one boss at a time
    var hasBoss = false;
    for (var bi = 0; bi < objects.length; bi++) { if (objects[bi].isBoss && objects[bi].alive) hasBoss = true; }
    if (!hasBoss && rng() < 0.3) {
      isBoss = true;
      type = 'egg'; // boss is always an egg type
    }
  }
  var isWindUp = (type === 'windUp');
  objects.push({
    type: type,
    x: spawnX,
    y: -40,
    vx: isMeteor ? (rng() - 0.5) * 2.5 : isBouncyBall ? (rng() - 0.5) * 3 : isWindUp ? 0 : (rng() - 0.5) * 0.8,
    vy: initVY,
    alive: true,
    fragile: fragile,
    bounces: 0,
    spawnTime: Date.now(),
    rot: 0,
    squashX: 1,
    squashY: 1,
    golden: golden,
    powerup: powerup,
    isBouncyBall: isBouncyBall,
    isDecoy: isDecoy,
    isWindUp: isWindUp,
    isBoss: isBoss,
    bossHP: isBoss ? 3 : 0,
    bossMaxHP: isBoss ? 3 : 0,
    windUpPhase: rng() * Math.PI * 2,
    shrunk: false
  });
}

// Line bounce check
function checkBounce(obj) {
  var now = Date.now();
  for (var i = 0; i < lines.length; i++) {
    var L = lines[i];
    if (L.done) continue;

    var lx = L.x2 - L.x1;
    var ly = L.y2 - L.y1;
    var len = Math.sqrt(lx * lx + ly * ly);
    if (len < 5) continue;

    // Line normal (ensure it points up)
    var nx = -ly / len;
    var ny = lx / len;
    if (ny > 0) { nx = -nx; ny = -ny; }

    // Distance from object to line
    var dx = obj.x - L.x1;
    var dy = obj.y - L.y1;
    var dist = dx * nx + dy * ny;

    // Projection along line
    var proj = (dx * lx + dy * ly) / (len * len);
    if (proj < -0.1 || proj > 1.1) continue;

    // Close enough and moving toward line?
    var hitDist = 22 + upgrades.widerLines.level * 2 + (skillTree.control[0].owned ? 3 : 0);
    if (dist > 0 && dist < hitDist) {
      var vn = obj.vx * nx + obj.vy * ny;
      if (vn < 0) {
        // Item 14: Boss objects lose HP on bounce
        if (obj.isBoss && obj.bossHP > 0) {
          obj.bossHP--;
          sfxBossHit();
          floatText('HP: ' + obj.bossHP + '/' + obj.bossMaxHP, obj.x, obj.y - 40, '#ff6b6b', 16);
          burst(obj.x, obj.y, '#fbbf24', 10);
          shakeAmount = 8;
          if (obj.bossHP <= 0) {
            // Boss defeated — fly to nearest safe zone
            var zR2 = getZone();
            var zL2 = getZoneLeft();
            var rDist = Math.abs(obj.x - (CW - WALL_W));
            var lDist = Math.abs(obj.x - WALL_W);
            if (rDist < lDist) {
              obj.vx = 4; obj.vy = (zR2.y + zR2.h / 2 - obj.y) * 0.05;
            } else {
              obj.vx = -4; obj.vy = (zL2.y + zL2.h / 2 - obj.y) * 0.05;
            }
            floatText('BOSS DEFEATED!', obj.x, obj.y - 60, '#fbbf24', 24);
          }
        }
        // Reflect
        obj.vx = obj.vx - 2 * vn * nx;
        obj.vy = obj.vy - 2 * vn * ny;
        var objBounce = BOUNCE;
        // Early level bounce boost (levels 1-4 get extra energy)
        if (level <= 4) {
          var earlyBoost = 1 + (5 - level) * 0.03;
          objBounce *= earlyBoost;
        }
        obj.vx *= objBounce;
        obj.vy *= objBounce;
        // Ensure minimum upward velocity so objects don't just dribble
        if (obj.vy > -4.0 && ny < 0) {
          obj.vy = Math.min(obj.vy, -5.0);
        }
        // Squash on impact
        obj.squashX = 1.4;
        obj.squashY = 0.6;
        // Push out
        obj.x += nx * (hitDist - dist);
        obj.y += ny * (hitDist - dist);
        // Store bounce reflection angle for directional particles
        obj._bounceAngle = Math.atan2(obj.vy, obj.vx);
        // Item 10: Decoy objects vanish on first bounce
        if (obj.isDecoy) {
          burst(obj.x, obj.y, 'rgba(255,255,255,0.5)', 12);
          sfxDecoyPoof();
          floatText('Decoy!', obj.x, obj.y - 25, 'rgba(255,255,255,0.7)', 16);
          obj.alive = false;
          return true;
        }
        // If object has very low speed, remove the line
        speed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
        if (speed < 1.5) {
          L.done = true;
        }
        return true;
      }
    }
  }
  return false;
}

// Particle burst - confetti with random shapes
function burst(x, y, color, n, dirAngle) {
  var shapes = ['circle', 'square', 'triangle', 'star'];
  for (var i = 0; i < n; i++) {
    var a;
    if (dirAngle !== undefined) {
      // Spray in a cone around the given direction
      a = dirAngle + (Math.random() - 0.5) * Math.PI * 0.8;
    } else {
      a = Math.random() * Math.PI * 2;
    }
    var s = 1 + Math.random() * 4;
    particles.push({
      x: x, y: y,
      vx: Math.cos(a) * s,
      vy: Math.sin(a) * s - 2,
      life: 1.0,
      color: color,
      size: 2 + Math.random() * 4,
      shape: shapes[Math.floor(Math.random() * shapes.length)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.2,
      easingType: Math.floor(Math.random() * 3) // 0=linear, 1=easeOut, 2=easeIn
    });
  }
}

function floatText(msg, x, y, color, size, startScale) {
  texts.push({ t: msg, x: x, y: y, life: 1.0, color: color, size: size || 15, scale: startScale || 1, targetScale: 1 });
}

function updateHUD() {
  var lifeStr = '';
  for (var i = 0; i < maxLives; i++) lifeStr += (i < lives) ? '\u2764' : '\u2661';
  document.getElementById('hudLives').textContent = 'Lives: ' + lifeStr;
  document.getElementById('hudLevel').textContent = level > 20 ? 'Level ' + level + ' ENDLESS' : 'Level ' + level;
  document.getElementById('hudCrash').textContent = 'Crashes: ' + strikes + '/3';
  var comboNeededHUD = Math.max(2, 4 - upgrades.fasterCombo.level - (skillTree.speed[0].owned ? 1 : 0));
  document.getElementById('hudCombo').textContent = 'Combo: ' + combo + '/' + comboNeededHUD;
  document.getElementById('hudStreak').textContent = 'Streak: ' + catchStreak;
  document.getElementById('hudTokens').textContent = 'Plummet Tokens: ' + fluffTokens;
  document.getElementById('homeTokenCount').textContent = fluffTokens;
}

document.getElementById('backBtn').onclick = function() {
  running = false;
  paused = false;
  stopBgMusic();
  // Track time played
  if (sessionStartTime > 0) {
    gameStats.totalTimePlayed += Math.floor((Date.now() - sessionStartTime) / 1000);
    saveProgress();
  }
  lives = maxLives; lifeFrac = 0; strikes = 0; combo = 0; level = 1; totalCatches = 0; bounceCount = 0; catchStreak = 0; wind = 0; levelCrashes = 0; levelBounces = 0; levelTransitionPhase = 0; levelTransitionAlpha = 0; levelTransitionTimer = 0; catchFlashTimer = 0; crashFlashTimer = 0; levelMessageTimer = 0;
  bestStreakThisRun = 0; tokensThisRun = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  activeEffects.shield = 0; activeEffects.slowmo = 0; activeEffects.doubleTokens = 0; activeEffects.magnet = 0;
  comboMultiplier = 1; comboMultiplierTimer = 0;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  timeFreezeTimer = 0; deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000;
  countdownTimer = 0; countdownPhase = 0;
  cameraZoom = 1.0; cameraZoomTarget = 1.0; cameraZoomTimer = 0;
  comboFlashTimer = 0; nearMissFlash = 0; lastCatchType = ''; sameTypeComboCount = 0;
  gravityFlipZone = null; portalPairs = []; portalPendingEntry = null;
  shrinkRayTimer = 0; catchSlowmoTimer = 0; catchSlowmoFactor = 1.0;
  safeZonePhase = 0;
  bgBirds = []; bgShootingStars = [];
  objects = []; lines = []; particles = []; texts = [];
  spawnTimer = 800;
  document.getElementById('pauseOverlay').classList.remove('show');
  document.getElementById('startScreen').classList.remove('gone');
  document.getElementById('shieldBtn').style.display = 'none';
  updatePrestigeBtn();
  initLineColorSelector();
  updateHUD();
};

document.getElementById('pauseBtn').onclick = function() {
  if (!running) return;
  paused = !paused;
  document.getElementById('pauseOverlay').classList.toggle('show', paused);
};

function resumeGame() {
  paused = false;
  lastTime = 0;
  document.getElementById('pauseOverlay').classList.remove('show');
}

function activateFloorShield() {
  if (shieldUsed || !running || paused) return;
  if (upgrades.shieldFloor.level === 0) return;
  shieldUsed = true;
  shieldActive = true;
  shieldTimeLeft = upgrades.shieldFloor.level * 2000;
  document.getElementById('shieldBtn').classList.add('used');
  checkAchievements();
}

function updateShieldBtn() {
  var btn = document.getElementById('shieldBtn');
  if (upgrades.shieldFloor.level > 0 && running) {
    btn.style.display = 'flex';
  } else {
    btn.style.display = 'none';
  }
}

function quitToHome() {
  running = false;
  paused = false;
  stopBgMusic();
  if (sessionStartTime > 0) {
    gameStats.totalTimePlayed += Math.floor((Date.now() - sessionStartTime) / 1000);
    saveProgress();
  }
  lives = maxLives; lifeFrac = 0; strikes = 0; combo = 0; level = 1; totalCatches = 0; bounceCount = 0; catchStreak = 0; wind = 0; levelCrashes = 0; levelBounces = 0; levelTransitionPhase = 0; levelTransitionAlpha = 0; levelTransitionTimer = 0; catchFlashTimer = 0; crashFlashTimer = 0; levelMessageTimer = 0;
  bestStreakThisRun = 0; tokensThisRun = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  activeEffects.shield = 0; activeEffects.slowmo = 0; activeEffects.doubleTokens = 0; activeEffects.magnet = 0;
  comboMultiplier = 1; comboMultiplierTimer = 0;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  timeFreezeTimer = 0; deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000;
  countdownTimer = 0; countdownPhase = 0;
  cameraZoom = 1.0; cameraZoomTarget = 1.0; cameraZoomTimer = 0;
  comboFlashTimer = 0; nearMissFlash = 0; lastCatchType = ''; sameTypeComboCount = 0;
  gravityFlipZone = null; portalPairs = []; portalPendingEntry = null;
  shrinkRayTimer = 0; catchSlowmoTimer = 0; catchSlowmoFactor = 1.0;
  safeZonePhase = 0;
  bgBirds = []; bgShootingStars = [];
  objects = []; lines = []; particles = []; texts = [];
  spawnTimer = 800;
  document.getElementById('pauseOverlay').classList.remove('show');
  document.getElementById('startScreen').classList.remove('gone');
  document.getElementById('shieldBtn').style.display = 'none';
  updatePrestigeBtn();
  initLineColorSelector();
  updateHUD();
}

function closeTutorial() {
  document.getElementById('tutorial').classList.remove('show');
  localStorage.setItem('fluffTutorialSeen', 'true');
  hasSeenTutorial = true;
  tutorialStepIdx = 0;
  running = true;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  timeFreezeTimer = 0; deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000 + Math.random() * 15000;
  lastCatchType = ''; sameTypeComboCount = 0;
  // New mechanics resets
  safeZonePhase = 0;
  gravityFlipZone = null;
  lastTapTime = 0; lastTapX = 0; lastTapY = 0;
  portalPairs = []; portalPendingEntry = null;
  shrinkRayTimer = 0;
  catchSlowmoTimer = 0; catchSlowmoFactor = 1.0;
  // Countdown (item 20)
  countdownTimer = 1600;
  countdownPhase = 3;
  spawnTimer = 5000;
  document.getElementById('shieldBtn').classList.remove('used');
  updateShieldBtn();
  lastTime = 0;
  updateHUD();
}

// Game events
function onBounce(obj) {
  obj.bounces++;
  combo++;
  bounceCount++;
  levelBounces++;


  // Score multiplier based on level + prestige + combo
  var multiplier = 1 + Math.floor((level - 1) / 3);
  var tokens = Math.floor(3 * multiplier * prestigeMultiplier * comboMultiplier);
  if (obj.halfTokens) tokens = Math.floor(tokens / 2); // Split objects worth half (item 10)
  if (activeEffects.doubleTokens > 0) tokens *= 2;
  // Skill tree: luck2 — 15% chance double tokens on bounce reward
  if (skillTree.luck[1].owned && Math.random() < 0.15) tokens *= 2;
  if (bounceCount >= 5) {
    bounceCount = 0;
    fluffTokens += tokens;
    tokensThisRun += tokens;
    floatText('+' + tokens + ' Tokens!', obj.x, obj.y - 45, '#fbbf24');
    saveProgress();
  }
  // Flash effect at bounce location with directional particles
  flashes.push({ x: obj.x, y: obj.y, life: 1.0, size: 30 });
  // Spray particles in bounce reflection direction
  if (obj._bounceAngle !== undefined) {
    burst(obj.x, obj.y, '#c4b5fd', 6, obj._bounceAngle);
    delete obj._bounceAngle;
  }
  sfxBounce(obj.type);
  floatText('+1', obj.x, obj.y - 25, '#c4b5fd');
  checkAchievements();
  // Combo ready sound when reaching 3 (one away from life recovery)
  if (combo === 3) {
    sfxComboReady();
  }
  var comboNeeded = Math.max(2, 4 - upgrades.fasterCombo.level - (skillTree.speed[0].owned ? 1 : 0));
  if (combo >= comboNeeded) {
    combo = 0;
    if (lives < maxLives) {
      lifeFrac++;
      if (lifeFrac >= 6) { lifeFrac = 0; lives = Math.min(maxLives, lives + 1); }
      floatText('+Life progress!', CW / 2, CH / 2, '#66bb6a');
    }
  }
  updateHUD();
}

function onCrash(obj) {
  // Shield blocks the crash
  if (activeEffects.shield > 0) {
    burst(obj.x, obj.y, '#60a5fa', 15);
    floatText('Shielded!', obj.x, obj.y - 25, '#60a5fa', 22);
    obj.alive = false;
    activeEffects.shield = 0;
    updateHUD();
    return;
  }
  burst(obj.x, obj.y, '#ff6b6b', 18);
  sfxCrash();
  floatText('CRASH!', obj.x, obj.y - 25, '#ff6b6b', 28);
  shakeAmount = 15;
  crashFlashTimer = 10; // red border flash
  // Haptic feedback (item 18)
  if (navigator.vibrate) try { navigator.vibrate(150); } catch(e) {}
  obj.alive = false;
  strikes++;
  combo = 0;
  catchStreak = 0;
  comboMultiplier = 1;
  comboMultiplierTimer = 0;
  levelCrashes++;
  lastCatchType = '';
  sameTypeComboCount = 0;
  updateHUD();
  if (strikes >= 3) {
    triggerGameOver();
  }
}

function triggerGameOver() {
  running = false;
  stopBgMusic();
  sfxGameOver();
  document.getElementById('shieldBtn').style.display = 'none';
  // Update persistent bests and stats
  if (level > bestLevel) bestLevel = level;
  if (bestStreakThisRun > bestStreak) bestStreak = bestStreakThisRun;
  if (totalCatches > bestCatches) bestCatches = totalCatches;
  gameStats.totalGames++;
  gameStats.totalTokensEarned += tokensThisRun;
  if (level > gameStats.bestLevel) gameStats.bestLevel = level;
  if (sessionStartTime > 0) {
    gameStats.totalTimePlayed += Math.floor((Date.now() - sessionStartTime) / 1000);
  }
  // Item 15: Add leaderboard entry
  addLeaderboardEntry(level, totalCatches, tokensThisRun);
  saveProgress();
  // Show game over screen with stats and coloring
  var goLevelEl = document.getElementById('goLevel');
  goLevelEl.textContent = level;
  goLevelEl.style.color = level >= 10 ? '#fbbf24' : level >= 5 ? '#c0c0c0' : '';
  goLevelEl.style.webkitTextFillColor = level >= 10 ? '#fbbf24' : level >= 5 ? '#c0c0c0' : '';
  document.getElementById('goCatches').textContent = totalCatches;
  document.getElementById('goTokens').textContent = tokensThisRun;
  var goStreakEl = document.getElementById('goStreak');
  goStreakEl.textContent = bestStreakThisRun;
  goStreakEl.style.color = bestStreakThisRun > 10 ? '#fbbf24' : bestStreakThisRun > 5 ? '#c0c0c0' : '';
  goStreakEl.style.webkitTextFillColor = bestStreakThisRun > 10 ? '#fbbf24' : bestStreakThisRun > 5 ? '#c0c0c0' : '';
  document.getElementById('gameOverScreen').classList.add('show');
  // Reset share button text
  document.getElementById('shareScoreBtn').textContent = '\uD83D\uDD17 Share Score';
}

function dismissGameOver() {
  document.getElementById('gameOverScreen').classList.remove('show');
  lives = maxLives; lifeFrac = 0; strikes = 0; combo = 0; level = 1; totalCatches = 0; bounceCount = 0; catchStreak = 0; wind = 0; levelCrashes = 0; levelBounces = 0; levelTransitionPhase = 0; levelTransitionAlpha = 0; levelTransitionTimer = 0; catchFlashTimer = 0; crashFlashTimer = 0; levelMessageTimer = 0;
  bestStreakThisRun = 0; tokensThisRun = 0;
  activeEffects.shield = 0; activeEffects.slowmo = 0; activeEffects.doubleTokens = 0; activeEffects.magnet = 0;
  comboMultiplier = 1; comboMultiplierTimer = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  timeFreezeTimer = 0; deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000;
  countdownTimer = 0; countdownPhase = 0;
  cameraZoom = 1.0; cameraZoomTarget = 1.0; cameraZoomTimer = 0;
  comboFlashTimer = 0; nearMissFlash = 0; lastCatchType = ''; sameTypeComboCount = 0;
  gravityFlipZone = null; portalPairs = []; portalPendingEntry = null;
  shrinkRayTimer = 0; catchSlowmoTimer = 0; catchSlowmoFactor = 1.0;
  safeZonePhase = 0;
  bgBirds = []; bgShootingStars = [];
  objects = []; lines = []; particles = []; texts = [];
  spawnTimer = 800;
  document.getElementById('startScreen').classList.remove('gone');
  updatePrestigeBtn();
  initLineColorSelector();
  updateHUD();
}

function onCatch(obj) {
  // Start catch animation instead of instant removal
  if (!obj.catching) {
    obj.catching = true;
    obj.catchTimer = 15;
    // Determine which wall it's near for animation target
    obj.catchTargetX = obj.x > CW / 2 ? CW : 0;
  }
  obj.alive = false;

  // Decoy — poof on catch with no reward, no penalty
  if (obj.isDecoy) {
    burst(obj.x, obj.y, 'rgba(255,255,255,0.4)', 10);
    sfxDecoyPoof();
    floatText('Decoy!', obj.x, obj.y - 25, 'rgba(255,255,255,0.6)', 16);
    return;
  }

  // Meteor penalty!
  if (obj.type === 'meteor') {
    burst(obj.x, obj.y, '#ff8c00', 30);
    sfxBomb();
    floatText('METEOR! -1 Life!', obj.x, obj.y - 25, '#ff8c00', 28);
    shakeAmount = 25;
    lives--;
    catchStreak = 0;
    if (lives <= 0) {
      strikes = 3;
      onCrash(obj);
    }
    updateHUD();
    return;
  }

  // Power-up activation
  if (obj.type === 'powerup' && obj.powerup) {
    burst(obj.x, obj.y, '#fbbf24', 20);
    if (obj.powerup === 'shield') sfxShieldPickup();
    else if (obj.powerup === 'magnet') sfxMagnetPickup();
    else if (obj.powerup === 'shrinkRay') sfxShrinkRay();
    else sfxDoublePickup();
    if (obj.powerup === 'shield') {
      activeEffects.shield = 8000;
      floatText('Shield! 8s', obj.x, obj.y - 25, '#60a5fa', 22);
    } else if (obj.powerup === 'doubleTokens') {
      activeEffects.doubleTokens = 10000;
      floatText('2x Tokens! 10s', obj.x, obj.y - 25, '#fbbf24', 22);
    } else if (obj.powerup === 'magnet') {
      activeEffects.magnet = 8000;
      floatText('Magnet! 8s', obj.x, obj.y - 25, '#f472b6', 22);
    } else if (obj.powerup === 'shrinkRay') {
      shrinkRayTimer = 5000;
      // Shrink all current objects
      for (var sri = 0; sri < objects.length; sri++) {
        if (objects[sri].alive && objects[sri].type !== 'powerup') objects[sri].shrunk = true;
      }
      floatText('SHRINK RAY! 5s', obj.x, obj.y - 25, '#c084fc', 22);
    }
    updateHUD();
    return;
  }

  // Track catch type for stats (item 17)
  if (!gameStats.catchesByType[obj.type]) gameStats.catchesByType[obj.type] = 0;
  gameStats.catchesByType[obj.type]++;
  gameStats.totalCatches++;

  // Item 13: Season pass XP
  addSeasonXP(1);

  // Item 14: Boss catch — 20 tokens
  if (obj.isBoss) {
    var bossTokens = 20;
    if (activeEffects.doubleTokens > 0) bossTokens *= 2;
    bossTokens = Math.floor(bossTokens * comboMultiplier * prestigeMultiplier);
    fluffTokens += bossTokens;
    tokensThisRun += bossTokens;
    burst(obj.x, obj.y, '#ffd700', 30);
    floatText('BOSS! +' + bossTokens + ' tokens!', obj.x, obj.y - 35, '#ffd700', 24);
    saveProgress();
  }

  // Item 4: Merged bonus — 5x tokens
  if (obj._mergedBonus) {
    var mergeTokens = Math.floor(15 * 5 * comboMultiplier * prestigeMultiplier);
    if (activeEffects.doubleTokens > 0) mergeTokens *= 2;
    fluffTokens += mergeTokens;
    tokensThisRun += mergeTokens;
    burst(obj.x, obj.y, '#ffd700', 25);
    floatText('5x MERGE! +' + mergeTokens, obj.x, obj.y - 25, '#ffd700', 24);
    totalCatches++;
    catchStreak++;
    if (catchStreak > bestStreakThisRun) bestStreakThisRun = catchStreak;
    saveProgress();
    updateHUD();
    return;
  }

  // Item 6: Wind-up objects worth 2x tokens
  if (obj.isWindUp) {
    var windUpTokens = Math.floor(6 * (1 + Math.floor((level - 1) / 3)) * comboMultiplier * prestigeMultiplier);
    if (activeEffects.doubleTokens > 0) windUpTokens *= 2;
    fluffTokens += windUpTokens;
    tokensThisRun += windUpTokens;
    sfxWindUp();
    floatText('Wind-Up! +' + windUpTokens, obj.x, obj.y - 25, '#f59e0b', 20);
    totalCatches++;
    catchStreak++;
    if (catchStreak > bestStreakThisRun) bestStreakThisRun = catchStreak;
    saveProgress();
    updateHUD();
    return;
  }

  // Skill tree: luck2 — 15% chance double tokens
  var luckyDouble = skillTree.luck[1].owned && Math.random() < 0.15;

  // Combo multiplier update (item 8)
  var prevComboMult = comboMultiplier;
  if (comboMultiplierTimer > 0 && comboMultiplierTimer < COMBO_TIMEOUT) {
    comboMultiplier = Math.min(4, comboMultiplier + 1);
  } else {
    comboMultiplier = 1;
  }
  comboMultiplierTimer = 1; // will count up in loop
  comboMultiplierDisplay = 120; // frames to show
  // Combo flash tint (item 4 visual)
  if (comboMultiplier > prevComboMult && comboMultiplier >= 2) {
    comboFlashTimer = 300; // 300ms flash
    comboFlashColor = comboMultiplier >= 4 ? '#ff6b6b' : comboMultiplier >= 3 ? '#ff8c00' : '#fbbf24';
  }

  // Golden egg bonus
  if (obj.golden) {
    var goldenBonus = 15 * (1 + Math.floor((level - 1) / 3));
    if (activeEffects.doubleTokens > 0) goldenBonus *= 2;
    if (luckyDouble) goldenBonus *= 2;
    goldenBonus = Math.floor(goldenBonus * comboMultiplier * prestigeMultiplier);
    fluffTokens += goldenBonus;
    tokensThisRun += goldenBonus;
    burst(obj.x, obj.y, '#fbbf24', 25);
    safeZoneConfetti(obj.x, obj.y);
    sfxCatch();
    sfxCatchDing(); // escalating ding
    catchFlashTimer = 10; // green border flash
    floatText('GOLDEN! +' + goldenBonus, obj.x, obj.y - 25, '#fbbf24', 24);
    totalCatches++;
    catchStreak++;
    if (catchStreak > bestStreakThisRun) bestStreakThisRun = catchStreak;
    saveProgress();
    updateHUD();
    return;
  }

  // Confetti burst on safe zone catch (item 1)
  safeZoneConfetti(obj.x, obj.y);
  burst(obj.x, obj.y, '#66bb6a', 15);
  sfxCatch(obj.type);
  sfxCatchZone();
  sfxCatchDing(); // escalating ding
  catchFlashTimer = 10; // green border flash
  totalCatches++;
  catchStreak++;
  if (catchStreak > bestStreakThisRun) bestStreakThisRun = catchStreak;

  // Same-type combo (item 7)
  if (lastCatchType === obj.type && obj.type !== 'powerup') {
    sameTypeComboCount++;
    if (sameTypeComboCount >= 2) {
      var sameBonus = 5;
      if (luckyDouble) sameBonus *= 2;
      fluffTokens += sameBonus;
      tokensThisRun += sameBonus;
      floatText('SAME TYPE COMBO! +' + sameBonus, obj.x, obj.y - 55, '#22d3ee', 20);
      saveProgress();
    }
  } else {
    sameTypeComboCount = 1;
  }
  lastCatchType = obj.type;

  // Crowd cheer on 3x+ combo (item 22)
  if (comboMultiplier >= 3 && crowdCheerTimer <= 0) {
    sfxCrowdCheer();
    crowdCheerTimer = 3000;
  }
  if (crowdCheerTimer > 0) crowdCheerTimer -= 16;

  // Streak bonus + combo multiplier (items 8, 14)
  if (catchStreak >= 4) {
    var streakBonus = Math.floor(catchStreak * 3 * comboMultiplier * prestigeMultiplier);
    if (luckyDouble) streakBonus *= 2;
    fluffTokens += streakBonus;
    tokensThisRun += streakBonus;
    floatText('Streak x' + catchStreak + '! +' + streakBonus, obj.x, obj.y - 50, '#ff9800', 20);
    saveProgress();
  }
  // Skill tree luck2: visual indicator when double tokens triggered
  if (luckyDouble) {
    floatText('LUCKY 2x!', obj.x, obj.y - 70, '#a78bfa', 18);
  }

  // Endless mode — no level cap after 20
  var newLevel = 1 + Math.floor(totalCatches / 3);
  if (newLevel > level) {
    // Calculate stars for completed level
    var stars = 3;
    if (levelCrashes >= 2) stars = 1;
    else if (levelCrashes >= 1) stars = 2;
    // Bonus: if high bounces, keep 3 stars even with 1 crash
    if (levelBounces >= 10 && levelCrashes <= 1) stars = Math.max(stars, 2);
    if (levelBounces >= 15 && levelCrashes === 0) stars = 3;

    // Extend levelStars array if needed for endless mode
    while (levelStars.length < level) levelStars.push(0);
    levelStars[level - 1] = Math.max(levelStars[level - 1], stars);
    showStars = stars;
    showStarsTimer = 180; // show for 3 seconds

    // Star bonus tokens
    var starBonus = stars * 5;
    fluffTokens += starBonus;
    tokensThisRun += starBonus;
    saveProgress();

    // Perfect level achievement — completed level with zero crashes
    if (levelCrashes === 0 && earnedAchievements.indexOf('perfectLevel') < 0) {
      earnedAchievements.push('perfectLevel');
      achievementPopup = { name: 'Perfect Level', icon: '\uD83D\uDC8E', timer: 180 };
      try { localStorage.setItem('fluffAchievements', JSON.stringify(earnedAchievements)); } catch(e) {}
    }

    level = newLevel;
    levelCrashes = 0;
    levelBounces = 0;
    spawnPauseTimer = 2500; // 2.5 second breather before new objects spawn
    sfxLevelUp();
    // Level-up fanfare
    levelUpFlash = 20;
    levelUpBanner = 120;
    levelUpBannerLevel = level;
    // Smooth screen transition between levels — fade to black and back
    levelTransitionPhase = 1; // start fade out
    levelTransitionTimer = 300; // 300ms fade out
    levelTransitionAlpha = 0;
    // Encouraging message between levels
    levelMessage = encouragingMessages[Math.floor(Math.random() * encouragingMessages.length)];
    levelMessageTimer = 120; // display for ~2 seconds
    // Camera zoom on level transition (item 19)
    cameraZoomTarget = 1.05;
    cameraZoomTimer = 1000;
    // Milestone check (item 14)
    checkMilestones();
    // Big burst of particles at center
    for (var lb = 0; lb < 30; lb++) {
      var lbAngle = (lb / 30) * Math.PI * 2;
      var lbSpeed = 2 + Math.random() * 4;
      particles.push({
        x: CW / 2, y: CH / 2,
        vx: Math.cos(lbAngle) * lbSpeed,
        vy: Math.sin(lbAngle) * lbSpeed,
        life: 1.2,
        color: ['#fbbf24', '#f59e0b', '#fde68a', '#fff'][Math.floor(Math.random() * 4)],
        size: 3 + Math.random() * 4,
        shape: ['star', 'circle', 'triangle'][Math.floor(Math.random() * 3)],
        rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.15
      });
    }
    if (level > bestLevel) { bestLevel = level; saveProgress(); }

    // Check for line color unlocks (item 12)
    for (var lci = 0; lci < lineColors.length; lci++) {
      if (level >= lineColors[lci].unlockLevel && unlockedLineColors.indexOf(lci) < 0) {
        unlockedLineColors.push(lci);
        floatText('New line colour unlocked!', CW / 2, CH / 2 + 130, '#c084fc', 18);
        saveProgress();
      }
    }

  } else {
    floatText('Caught!', obj.x, obj.y - 25, '#66bb6a');
  }
  // Check for golden egg achievement
  if (obj.golden && earnedAchievements.indexOf('goldenEgg') < 0) {
    earnedAchievements.push('goldenEgg');
    achievementPopup = { name: 'Golden Egg', icon: '\u2728', timer: 180 };
    try { localStorage.setItem('fluffAchievements', JSON.stringify(earnedAchievements)); } catch(e) {}
  }
  checkAchievements();
  updateHUD();
}

// MAIN LOOP
var lastTime = 0;

// Initialize demo objects for start screen
function initDemo() {
  demoObjects = [];
  for (var i = 0; i < 6; i++) {
    var demoTypes = ['egg'];
    demoObjects.push({
      type: demoTypes[Math.floor(Math.random() * demoTypes.length)],
      x: 50 + Math.random() * (CW - 100),
      y: 50 + Math.random() * (CH - 150),
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      alive: true
    });
  }
}
initDemo();

function drawDemoScreen(now) {
  // Background
  var grad = ctx.createLinearGradient(0, 0, 0, CH);
  grad.addColorStop(0, '#f0fdfa');
  grad.addColorStop(0.5, '#ccfbf1');
  grad.addColorStop(1, '#99f6e4');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, CW, CH);

  // Update and draw demo objects bouncing around
  for (var i = 0; i < demoObjects.length; i++) {
    var obj = demoObjects[i];
    obj.x += obj.vx;
    obj.y += obj.vy;
    obj.vy += 0.02;

    // Bounce off edges
    if (obj.x < 30) { obj.x = 30; obj.vx = Math.abs(obj.vx); }
    if (obj.x > CW - 30) { obj.x = CW - 30; obj.vx = -Math.abs(obj.vx); }
    if (obj.y < 30) { obj.y = 30; obj.vy = Math.abs(obj.vy); }
    if (obj.y > CH - 30) { obj.y = CH - 30; obj.vy = -Math.abs(obj.vy) * 0.9; }

    // Trail particles
    if (frameCount % 4 === 0) {
      var trailColor = obj.type === 'egg' ? '#fef3c7' : '#93c5fd';
      demoParticles.push({
        x: obj.x, y: obj.y,
        vx: (Math.random() - 0.5) * 0.5,
        vy: -0.3 - Math.random() * 0.3,
        life: 0.5,
        color: trailColor,
        size: 2 + Math.random() * 2
      });
    }

    // Draw object
    ctx.save();
    ctx.globalAlpha = 0.4;
    ctx.translate(obj.x, obj.y);
    if (obj.type === 'egg') {
      ctx.beginPath();
      ctx.ellipse(0, 0, 13, 17, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#fef3c7';
      ctx.fill();
      ctx.strokeStyle = '#d4a574';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(-20, -14, 40, 28);
      ctx.strokeStyle = '#93c5fd';
      ctx.lineWidth = 2;
      ctx.strokeRect(-20, -14, 40, 28);
    }
    ctx.restore();
  }

  // Update demo particles
  for (var i = demoParticles.length - 1; i >= 0; i--) {
    var p = demoParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.life -= 0.02;
    if (p.life <= 0) { demoParticles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life * 0.3;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;
}

function loop(now) {
  try {
    requestAnimationFrame(loop);
    frameCount++;
    if (!running) {
      drawDemoScreen(now);
      return;
    }
    if (paused) return;

    var dt = 0;
    if (lastTime > 0) {
      dt = now - lastTime;
      if (dt > 50) dt = 16;
    } else {
      dt = 16;
    }
    lastTime = now;

    // Countdown timer (item 20)
    if (countdownTimer > 0) {
      countdownTimer -= dt;
      if (countdownTimer > 1200) countdownPhase = 3;
      else if (countdownTimer > 800) countdownPhase = 2;
      else if (countdownTimer > 400) countdownPhase = 1;
      else if (countdownTimer > 0) countdownPhase = -1; // GO
      else { countdownPhase = 0; spawnTimer = 100; }
    }

    // Level transition fade update
    if (levelTransitionPhase > 0) {
      levelTransitionTimer -= dt;
      if (levelTransitionPhase === 1) {
        // Fading out (to black)
        levelTransitionAlpha = Math.min(1, 1 - levelTransitionTimer / 300);
        if (levelTransitionTimer <= 0) { levelTransitionPhase = 2; levelTransitionTimer = 200; }
      } else if (levelTransitionPhase === 2) {
        // Hold black
        levelTransitionAlpha = 1;
        if (levelTransitionTimer <= 0) { levelTransitionPhase = 3; levelTransitionTimer = 300; }
      } else if (levelTransitionPhase === 3) {
        // Fading in (from black)
        levelTransitionAlpha = Math.max(0, levelTransitionTimer / 300);
        if (levelTransitionTimer <= 0) { levelTransitionPhase = 0; levelTransitionAlpha = 0; }
      }
    }

    // Camera zoom (item 19)
    if (cameraZoomTimer > 0) {
      cameraZoomTimer -= dt;
      if (cameraZoomTimer > 500) {
        cameraZoom += (cameraZoomTarget - cameraZoom) * 0.05;
      } else {
        cameraZoom += (1.0 - cameraZoom) * 0.05;
      }
    } else {
      cameraZoom += (1.0 - cameraZoom) * 0.1;
    }

    // Golden zone timer (item 8)
    if (goldenZone) {
      goldenZone.timer -= dt;
      if (goldenZone.timer <= 0) goldenZone = null;
    }
    if (!goldenZone && running) {
      goldenZoneSpawnTimer -= dt;
      if (goldenZoneSpawnTimer <= 0 && countdownPhase === 0) {
        var gzH = getZoneHeight() * 0.4;
        var gzSide = Math.random() > 0.5 ? 'right' : 'left';
        var gzY = CH * 0.2 + Math.random() * (CH * 0.5);
        goldenZone = { side: gzSide, y: gzY, h: gzH, timer: 8000, maxTimer: 8000 };
        goldenZoneSpawnTimer = 30000 + Math.random() * 15000;
      }
    }

    // Combo flash timer (item 4)
    if (comboFlashTimer > 0) comboFlashTimer -= dt;

    // Ambient sounds (item 23)
    ambientSoundTimer -= dt;
    if (ambientSoundTimer <= 0 && countdownPhase === 0) {
      if (level >= 1 && level <= 8) {
        // Day: bird chirp
        sfxBirdChirp();
        ambientSoundTimer = 3000 + Math.random() * 5000;
      } else if (level >= 9 && level <= 16) {
        // Night: cricket
        sfxCricket();
        ambientSoundTimer = 2000 + Math.random() * 3000;
      } else if (level >= 17) {
        // Space: cosmic hum
        sfxCosmicHum();
        ambientSoundTimer = 4000 + Math.random() * 6000;
      } else {
        ambientSoundTimer = 3000;
      }
    }

    // Background birds/shooting stars (item 5)
    if (level >= 1 && level <= 8 && frameCount % 300 === 0 && bgBirds.length < 3) {
      spawnBgBird();
    }
    if (level >= 13 && frameCount % 180 === 0 && bgShootingStars.length < 2) {
      spawnShootingStar();
    }
    // Update birds
    for (var bi = bgBirds.length - 1; bi >= 0; bi--) {
      bgBirds[bi].x += bgBirds[bi].vx;
      bgBirds[bi].wingPhase += 0.1;
      if (bgBirds[bi].x > CW + 50) bgBirds.splice(bi, 1);
    }
    // Update shooting stars
    for (var si = bgShootingStars.length - 1; si >= 0; si--) {
      bgShootingStars[si].x += bgShootingStars[si].vx;
      bgShootingStars[si].y += bgShootingStars[si].vy;
      bgShootingStars[si].life -= 0.01;
      if (bgShootingStars[si].life <= 0 || bgShootingStars[si].x > CW + 50) bgShootingStars.splice(si, 1);
    }

    // Update active power-up effect timers
    if (activeEffects.shield > 0) activeEffects.shield -= dt;
    if (activeEffects.doubleTokens > 0) activeEffects.doubleTokens -= dt;
    if (activeEffects.magnet > 0) activeEffects.magnet -= dt;

    // Combo multiplier timer (item 8)
    if (comboMultiplierTimer > 0) {
      comboMultiplierTimer += dt;
      if (comboMultiplierTimer > COMBO_TIMEOUT) {
        comboMultiplier = 1;
        comboMultiplierTimer = 0;
      }
    }
    if (comboMultiplierDisplay > 0) comboMultiplierDisplay--;
    // Update combo multiplier display element
    var cmEl = document.getElementById('comboMultiplier');
    if (comboMultiplier > 1 && comboMultiplierDisplay > 0) {
      cmEl.textContent = comboMultiplier + 'x COMBO!';
      cmEl.style.opacity = Math.min(1, comboMultiplierDisplay / 30);
      cmEl.style.fontSize = (28 + comboMultiplier * 4) + 'px';
    } else {
      cmEl.style.opacity = '0';
    }

    if (shieldActive && shieldTimeLeft > 0) {
      shieldTimeLeft -= dt;
      if (shieldTimeLeft <= 0) { shieldTimeLeft = 0; shieldActive = false; }
    }
    catchSlowmoFactor = 1.0;

    // Item 1: Moving safe zones — update phase
    safeZonePhase += dt * 0.001;

    // Item 2: Gravity flip zone timer
    if (gravityFlipZone) {
      gravityFlipZone.timer -= dt;
      if (gravityFlipZone.timer <= 0) gravityFlipZone = null;
    }

    // Item 9: Shrink ray timer
    if (shrinkRayTimer > 0) {
      shrinkRayTimer -= dt;
      if (shrinkRayTimer <= 0) {
        // Unshrink all objects
        for (var si = 0; si < objects.length; si++) {
          if (objects[si].shrunk) objects[si].shrunk = false;
        }
      }
    }

    // Item 8: Portal pairs update
    for (var ppi = 0; ppi < portalPairs.length; ppi++) {
      var pp = portalPairs[ppi];
      // Check if any object enters the entry portal
      for (var poi = 0; poi < objects.length; poi++) {
        var pobj = objects[poi];
        if (!pobj.alive || pobj._portalCooldown > 0) continue;
        var pdx = pobj.x - pp.entry.x;
        var pdy = pobj.y - pp.entry.y;
        if (Math.sqrt(pdx * pdx + pdy * pdy) < 25) {
          // Teleport to exit
          pobj.x = pp.exit.x;
          pobj.y = pp.exit.y;
          pobj._portalCooldown = 30; // frames cooldown
          sfxPortalEnter();
          burst(pp.entry.x, pp.entry.y, '#60a5fa', 10);
          burst(pp.exit.x, pp.exit.y, '#fb923c', 10);
        }
      }
    }
    // Portal cooldown decay
    for (var poi2 = 0; poi2 < objects.length; poi2++) {
      if (objects[poi2]._portalCooldown > 0) objects[poi2]._portalCooldown--;
    }

    var grav = GRAVITY; // direct gravity, no slow-mo multipliers
    // Difficulty multiplier (item 23)
    grav *= difficultyMultipliers[gameDifficulty].gravity;

    // Wind (starts at level 8)
    windTimer -= dt;
    if (windTimer <= 0) {
      targetWind = (level >= 5) ? (Math.random() - 0.5) * 0.001 * level : 0;
      windTimer = 2000 + Math.random() * 3000;
    }
    // Wind easing — smoothly transition toward target
    wind += (targetWind - wind) * 0.02;


    // Spawn pause timer (breather at level start)
    if (spawnPauseTimer > 0) {
      spawnPauseTimer -= dt;
    }

    // Spawn (skip during countdown)
    if (countdownPhase === 0) {
      spawnTimer -= dt;
      if (spawnTimer <= 0 && spawnPauseTimer <= 0) {
        var activeCount = 0;
        var hasRecentSpawn = false;
        for (var i = 0; i < objects.length; i++) {
          if (objects[i].alive) {
            activeCount++;
            // Don't spawn if any object is still near the top (just spawned)
            if (objects[i].y < 80) hasRecentSpawn = true;
          }
        }
        var maxObj = Math.min(2 + level, 12) + difficultyMultipliers[gameDifficulty].maxObjBonus;
        if (activeCount < maxObj && !hasRecentSpawn) spawnObj();
        var spawnInterval = Math.max(900, 3200 - level * 140);
        // Difficulty spawn rate
        spawnInterval /= difficultyMultipliers[gameDifficulty].spawnRate;
        spawnTimer = spawnInterval;
      }
    }

    // Expire lines after 2 seconds (+ skill tree bonus)
    var now2 = Date.now();
    var lineLifeMs = 2000 + (skillTree.control[2].owned ? 1000 : 0);
    for (var i = 0; i < lines.length; i++) {
      var L = lines[i];
      if (L.done) continue;
      if (now2 - L.born > lineLifeMs) L.done = true;
    }
    var newLines = [];
    for (var i = 0; i < lines.length; i++) {
      if (!lines[i].done) newLines.push(lines[i]);
    }
    lines = newLines;

    // Update objects
    var zone = getZone();
    var zoneL = getZoneLeft();
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (!obj.alive) continue;

      var objGrav;
      if (obj.type === 'meteor') {
        var meteorSlowFactor = Math.max(0.5, 1 - upgrades.slowerMeteors.level * 0.05);
        objGrav = grav * 1.6 * meteorSlowFactor;
      } else {
        objGrav = grav;
      }
      // Per-level gravity boost for later difficulty scaling
      objGrav += level * 0.002;
      // Item 2: Gravity flip zone — reverse gravity inside zone
      if (gravityFlipZone) {
        var gfDx = obj.x - gravityFlipZone.x;
        var gfDy = obj.y - gravityFlipZone.y;
        if (Math.sqrt(gfDx * gfDx + gfDy * gfDy) < gravityFlipZone.radius) {
          objGrav = -objGrav;
        }
      }
      // Item 9: Shrink ray — smaller objects
      if (shrinkRayTimer > 0 && !obj.shrunk && obj.type !== 'powerup') {
        obj.shrunk = true;
      }
      obj.vy += objGrav;
      // Item 6: Wind-up objects orbit as they fall
      if (obj.isWindUp) {
        obj.windUpPhase += dt * 0.005;
        obj.vx = Math.sin(obj.windUpPhase) * 1.5;
      }
      obj.vx += wind; // wind push
      // Bouncy ball has less drag (item 6)
      var dragFactor = obj.isBouncyBall ? 0.999 : 0.998;
      obj.vx *= dragFactor;
      obj.vy *= dragFactor;
      obj.x += obj.vx;
      obj.y += obj.vy;

      // Bouncy ball bounces off left/right walls automatically (item 6)
      // But allow it to enter safe zones
      if (obj.isBouncyBall) {
        var bbInRightZone = (obj.y > zone.y && obj.y < zone.y + zone.h);
        var bbInLeftZone = (obj.y > zoneL.y && obj.y < zoneL.y + zoneL.h);
        if (!bbInLeftZone && obj.x < WALL_W + 15) {
          obj.x = WALL_W + 15;
          obj.vx = Math.abs(obj.vx) * 0.9;
          obj.vx += (Math.random() - 0.5) * 0.5;
        }
        if (!bbInRightZone && obj.x > CW - WALL_W - 15) {
          obj.x = CW - WALL_W - 15;
          obj.vx = -Math.abs(obj.vx) * 0.9;
          obj.vx += (Math.random() - 0.5) * 0.5;
        }
        if (frameCount % 20 === 0) {
          obj.vx += (Math.random() - 0.5) * 0.8;
        }
      }

      // Magnet effect (item 9) — pull objects toward nearest safe zone
      if (activeEffects.magnet > 0 && obj.type !== 'meteor') {
        var zR = getZone();
        var zL = getZoneLeft();
        var rCenterX = CW - WALL_W / 2;
        var rCenterY = zR.y + zR.h / 2;
        var lCenterX = WALL_W / 2;
        var lCenterY = zL.y + zL.h / 2;
        var dxR = rCenterX - obj.x, dyR = rCenterY - obj.y;
        var dxL = lCenterX - obj.x, dyL = lCenterY - obj.y;
        var distR = Math.sqrt(dxR * dxR + dyR * dyR);
        var distL = Math.sqrt(dxL * dxL + dyL * dyL);
        var magnetRange = 150;
        if (distR < magnetRange) {
          var force = 0.03 * (1 - distR / magnetRange);
          obj.vx += (dxR / distR) * force;
          obj.vy += (dyR / distR) * force;
        }
        if (distL < magnetRange) {
          var force = 0.03 * (1 - distL / magnetRange);
          obj.vx += (dxL / distL) * force;
          obj.vy += (dyL / distL) * force;
        }
      }

      // Rotation based on total speed (faster objects = faster spin)
      var totalSpeed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
      obj.rot += obj.type === 'meteor' ? obj.vx * 0.08 + 0.03 : obj.vx * 0.04 * Math.max(1, totalSpeed * 0.5);
      // Squash recovery (spring back to 1,1)
      obj.squashX += (1 - obj.squashX) * 0.15;
      obj.squashY += (1 - obj.squashY) * 0.15;

      // Wall bouncing (outside safe zone)
      var inRightZone = (obj.y > zone.y && obj.y < zone.y + zone.h);
      var inLeftZone = (obj.y > zoneL.y && obj.y < zoneL.y + zoneL.h);
      if (!inRightZone && obj.x > CW - WALL_W - 10) {
        obj.x = CW - WALL_W - 10; obj.vx = -Math.abs(obj.vx) * 0.6;
      }
      if (!inLeftZone && obj.x < WALL_W + 10) {
        obj.x = WALL_W + 10; obj.vx = Math.abs(obj.vx) * 0.6;
      }

      // Particle trail - with customisable effects (item 19)
      if (frameCount % 3 === 0) {
        var trailColor = obj.type === 'egg' ? '#fef3c7' : obj.type === 'meteor' ? '#ff8c00' : obj.type === 'bouncyBall' ? '#fbbf24' : obj.type === 'windUp' ? '#f59e0b' : obj.type === 'decoy' ? 'rgba(255,255,255,0.3)' : '#93c5fd';
        var trailShape = 'star';
        var trailVY = -0.5 - Math.random() * 0.5;
        if (activeTrailEffect === 'flames') {
          // Orange/red particles that rise
          var flameHue = Math.random() > 0.5 ? '#ff6b6b' : '#fb923c';
          trailColor = flameHue;
          trailVY = -1 - Math.random() * 1;
          trailShape = 'circle';
        } else if (activeTrailEffect === 'rainbow') {
          // Cycling hue
          var rainbowHue = ((now * 0.1 + obj.x) % 360);
          trailColor = 'hsl(' + rainbowHue + ', 80%, 60%)';
          trailShape = 'circle';
        }
        particles.push({
          x: obj.x + (Math.random() - 0.5) * 8,
          y: obj.y - 10,
          vx: (Math.random() - 0.5) * 0.3,
          vy: trailVY,
          life: 0.6,
          color: trailColor,
          size: 2 + Math.random() * 2,
          shape: trailShape,
          rot: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 0.1
        });
      }

      // Motion blur/streak trail based on velocity (item 2)
      var speed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
      if (speed > 2 && frameCount % 2 === 0) {
        var trailLen = Math.min(4, Math.floor(speed / 2));
        for (var ti = 0; ti < trailLen; ti++) {
          var tt = (ti + 1) / trailLen;
          var trColor = obj.type === 'egg' ? 'rgba(254,243,199,' : obj.type === 'meteor' ? 'rgba(255,140,0,' : obj.type === 'bouncyBall' ? 'rgba(251,191,36,' : 'rgba(147,197,253,';
          particles.push({
            x: obj.x - obj.vx * tt * 3,
            y: obj.y - obj.vy * tt * 3,
            vx: 0, vy: 0,
            life: 0.3 * (1 - tt * 0.5),
            color: trColor + (0.4 * (1 - tt)) + ')',
            size: (3 + speed * 0.5) * (1 - tt * 0.5),
            shape: 'circle',
            rot: 0,
            rotSpeed: 0
          });
        }
      }

      // Item 7: Conveyor lines — slide objects along the line
      if (activeLineType === 'conveyorLines') {
        for (var cli = 0; cli < lines.length; cli++) {
          var cL = lines[cli];
          if (cL.done) continue;
          var clx = cL.x2 - cL.x1, cly = cL.y2 - cL.y1;
          var clen = Math.sqrt(clx * clx + cly * cly);
          if (clen < 5) continue;
          var cnx = -cly / clen, cny = clx / clen;
          if (cny > 0) { cnx = -cnx; cny = -cny; }
          var cdx = obj.x - cL.x1, cdy = obj.y - cL.y1;
          var cdist = cdx * cnx + cdy * cny;
          var cproj = (cdx * clx + cdy * cly) / (clen * clen);
          if (cproj >= 0 && cproj <= 1 && cdist > 0 && cdist < 25) {
            // Find nearest safe zone
            var zR3 = getZone(); var zL3 = getZoneLeft();
            var rCX = CW - WALL_W / 2, lCX = WALL_W / 2;
            // Slide toward whichever end of line is closer to a safe zone
            var endX1Dist = Math.min(Math.abs(cL.x1 - rCX), Math.abs(cL.x1 - lCX));
            var endX2Dist = Math.min(Math.abs(cL.x2 - rCX), Math.abs(cL.x2 - lCX));
            var slideDir = endX2Dist < endX1Dist ? 1 : -1;
            obj.vx += (clx / clen) * slideDir * 0.15;
            obj.vy += (cly / clen) * slideDir * 0.15;
          }
        }
      }

      // Line bounce
      if (checkBounce(obj)) {
        // Line type effects (item 6) + skill tree bonuses
        if (activeLineType === 'stickyLines') {
          obj.vx *= 0.5;
          obj.vy *= 0.5;
        } else if (skillTree.control[1].owned) {
          // Skill tree sticky lines effect (30% slow)
          obj.vx *= 0.7;
          obj.vy *= 0.7;
        }
        if (activeLineType === 'bouncyLines') {
          obj.vx *= 1.3;
          obj.vy *= 1.3;
        }
        onBounce(obj);
      }

      // Floor shield bounce — redirect object toward nearest safe zone
      if (shieldActive && shieldTimeLeft > 0 && obj.y > CH - WALL_W - 20 && obj.vy > 0) {
        // Find nearest safe zone center
        var zoneR = getZone();
        var zoneLL = getZoneLeft();
        var rightCenter = { x: CW - WALL_W / 2, y: zoneR.y + zoneR.h / 2 };
        var leftCenter = { x: WALL_W / 2, y: zoneLL.y + zoneLL.h / 2 };
        var distR = Math.abs(obj.x - rightCenter.x);
        var distL = Math.abs(obj.x - leftCenter.x);
        var target = distR < distL ? rightCenter : leftCenter;
        // Calculate angle to target
        var dx = target.x - obj.x;
        var dy = target.y - obj.y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var speed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
        if (speed < 2) speed = 2;
        obj.vx = (dx / dist) * speed * 1.2;
        obj.vy = (dy / dist) * speed * 1.2;
        obj.y = CH - WALL_W - 21;
        // Shield bounce particles
        burst(obj.x, CH - WALL_W - 10, '#60a5fa', 12);
        continue;
      }

      // Item 10: Decoy objects that hit floor — no penalty
      if (obj.isDecoy && obj.y > CH - WALL_W - 5) {
        burst(obj.x, obj.y, 'rgba(255,255,255,0.3)', 8);
        sfxDecoyPoof();
        obj.alive = false;
        continue;
      }
      // Floor crash
      if (obj.y > CH - WALL_W - 5) {
        // Near miss check — crashed within 40px of safe zone edge
        var nearRight = Math.abs(obj.x - (CW - WALL_W)) < 40 && obj.y > zone.y - 40 && obj.y < zone.y + zone.h + 40;
        var nearLeft = Math.abs(obj.x - WALL_W) < 40 && obj.y > zoneL.y - 40 && obj.y < zoneL.y + zoneL.h + 40;
        if (nearRight || nearLeft) {
          sfxNearMiss();
          sfxCrowdGasp(); // Crowd gasp on near miss (item 22)
          nearMissFlash = 15; nearMissX = obj.x; // trigger screen edge flash
          floatText('So close!', obj.x, obj.y - 40, '#fde047', 18);
        }
        onCrash(obj);
        continue;
      }

      // Fluff zone catch (right wall)
      if (obj.x > zone.x && obj.y > zone.y && obj.y < zone.y + zone.h) {
        onCatch(obj);
      }

      // Fluff zone catch (left wall)
      if (obj.x < zoneL.w && obj.y > zoneL.y && obj.y < zoneL.y + zoneL.h) {
        onCatch(obj);
      }

      // Golden zone catch (item 8)
      if (goldenZone && obj.alive && obj.type !== 'meteor') {
        var gzX = goldenZone.side === 'right' ? CW - WALL_W : 0;
        var gzW = WALL_W;
        var inGZ = false;
        if (goldenZone.side === 'right' && obj.x > gzX && obj.y > goldenZone.y && obj.y < goldenZone.y + goldenZone.h) inGZ = true;
        if (goldenZone.side === 'left' && obj.x < gzW && obj.y > goldenZone.y && obj.y < goldenZone.y + goldenZone.h) inGZ = true;
        if (inGZ) {
          // Decoys poof in golden zone too — no reward
          if (obj.isDecoy) {
            burst(obj.x, obj.y, 'rgba(255,255,255,0.4)', 10);
            sfxDecoyPoof();
            floatText('Decoy!', obj.x, obj.y - 25, 'rgba(255,255,255,0.6)', 16);
            obj.alive = false;
            continue;
          }
          // 3x token bonus
          var gzTokens = Math.floor(15 * comboMultiplier * prestigeMultiplier);
          if (activeEffects.doubleTokens > 0) gzTokens *= 2;
          fluffTokens += gzTokens;
          tokensThisRun += gzTokens;
          burst(obj.x, obj.y, '#fbbf24', 30);
          safeZoneConfetti(obj.x, obj.y);
          floatText('GOLDEN! +' + gzTokens, obj.x, obj.y - 25, '#ffd700', 26);
          sfxCatch(obj.type);
          sfxCatchDing();
          catchFlashTimer = 10;
          obj.alive = false;
          totalCatches++;
          catchStreak++;
          if (catchStreak > bestStreakThisRun) bestStreakThisRun = catchStreak;
          goldenZone = null;
          saveProgress();
          updateHUD();
        }
      }
    }

    // Item 4: Chain reactions — merge colliding objects mid-air
    for (var ci1 = 0; ci1 < objects.length; ci1++) {
      var o1 = objects[ci1];
      if (!o1.alive || o1.type === 'meteor' || o1.type === 'powerup' || o1.isBoss || o1._merged) continue;
      for (var ci2 = ci1 + 1; ci2 < objects.length; ci2++) {
        var o2 = objects[ci2];
        if (!o2.alive || o2.type === 'meteor' || o2.type === 'powerup' || o2.isBoss || o2._merged) continue;
        var mdx = o1.x - o2.x, mdy = o1.y - o2.y;
        var mdist = Math.sqrt(mdx * mdx + mdy * mdy);
        if (mdist < 20) {
          // Merge! Create golden bonus object
          sfxMerge();
          burst(o1.x, o1.y, '#ffd700', 20);
          flashes.push({ x: o1.x, y: o1.y, life: 1.0, size: 50 });
          o1.alive = false;
          o2.alive = false;
          o1._merged = true;
          o2._merged = true;
          // Create merged object
          objects.push({
            type: 'egg', x: (o1.x + o2.x) / 2, y: (o1.y + o2.y) / 2,
            vx: (o1.vx + o2.vx) / 2, vy: (o1.vy + o2.vy) / 2,
            alive: true, fragile: 0, bounces: 0,
            spawnTime: Date.now(), rot: 0, squashX: 1.3, squashY: 1.3,
            golden: true, powerup: null,
            isBouncyBall: false,
            isDecoy: false, isWindUp: false, isBoss: false,
            bossHP: 0, bossMaxHP: 0, windUpPhase: 0, shrunk: false,
            _mergedBonus: true, small: false
          });
          floatText('MERGED! 5x!', (o1.x + o2.x) / 2, (o1.y + o2.y) / 2 - 30, '#ffd700', 22);
          break;
        }
      }
    }

    // Update catching animations
    for (var i = 0; i < objects.length; i++) {
      var cobj = objects[i];
      if (cobj.catching && cobj.catchTimer > 0) {
        cobj.catchTimer--;
        cobj.catchScale = cobj.catchTimer / 15;
        cobj.x += (cobj.catchTargetX - cobj.x) * 0.15;
      }
    }
    // Clean dead objects (keep catching objects until animation done)
    var alive = [];
    for (var i = 0; i < objects.length; i++) {
      if (objects[i].alive) alive.push(objects[i]);
      else if (objects[i].catching && objects[i].catchTimer > 0) alive.push(objects[i]);
    }
    objects = alive;

    // Update particles
    for (var i = particles.length - 1; i >= 0; i--) {
      var p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.08;
      p.life -= 0.02;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Update flashes
    for (var i = flashes.length - 1; i >= 0; i--) {
      flashes[i].life -= 0.06;
      if (flashes[i].life <= 0) flashes.splice(i, 1);
    }

    // Update floating texts
    for (var i = texts.length - 1; i >= 0; i--) {
      texts[i].y -= 0.8;
      texts[i].life -= 0.015;
      if (texts[i].life <= 0) texts.splice(i, 1);
    }

    // ======= DRAW =======
    // Screen shake + camera zoom (item 19)
    ctx.save();
    if (cameraZoom !== 1.0) {
      ctx.translate(CW / 2, CH / 2);
      ctx.scale(cameraZoom, cameraZoom);
      ctx.translate(-CW / 2, -CH / 2);
    }
    if (shakeAmount > 0) {
      var sx = (Math.random() - 0.5) * shakeAmount * 2;
      var sy = (Math.random() - 0.5) * shakeAmount * 2;
      ctx.translate(sx, sy);
      shakeAmount *= 0.85;
      if (shakeAmount < 0.5) shakeAmount = 0;
    }

    // Background gradient with smooth transitions between themes (item 3)
    var themeIdx = Math.min(level, 20) - 1;
    var theme = levelThemes[themeIdx];
    // Custom background theme override (item 12 progression)
    if (activeBgTheme) {
      for (var bti = 0; bti < bgThemeShop.length; bti++) {
        if (bgThemeShop[bti].id === activeBgTheme) {
          theme = bgThemeShop[bti].colors;
          break;
        }
      }
    }
    // Smooth transition
    if (bgThemeCurrent === null) bgThemeCurrent = theme;
    if (bgThemePrev === null) bgThemePrev = theme;
    if (bgThemeCurrent !== theme) {
      bgThemePrev = bgThemeCurrent;
      bgThemeCurrent = theme;
      bgThemeTransition = 0;
    }
    if (bgThemeTransition < 1) {
      bgThemeTransition = Math.min(1, bgThemeTransition + 0.005);
    }
    // Lerp hex colors for smooth blend
    function lerpColor(a, b, t) {
      var ah = parseInt(a.replace('#',''), 16);
      var bh = parseInt(b.replace('#',''), 16);
      var ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
      var br = (bh >> 16) & 0xff, bg2 = (bh >> 8) & 0xff, bb = bh & 0xff;
      var rr = Math.round(ar + (br - ar) * t);
      var rg = Math.round(ag + (bg2 - ag) * t);
      var rb = Math.round(ab + (bb - ab) * t);
      return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
    }
    var blendTop = lerpColor(bgThemePrev.top, bgThemeCurrent.top, bgThemeTransition);
    var blendMid = lerpColor(bgThemePrev.mid, bgThemeCurrent.mid, bgThemeTransition);
    var blendBot = lerpColor(bgThemePrev.bot, bgThemeCurrent.bot, bgThemeTransition);
    var grad = ctx.createLinearGradient(0, 0, 0, CH);
    grad.addColorStop(0, blendTop);
    grad.addColorStop(0.15, lerpColor(blendTop, blendMid, 0.3));
    grad.addColorStop(0.35, blendMid);
    grad.addColorStop(0.55, lerpColor(blendMid, blendBot, 0.4));
    grad.addColorStop(0.75, blendBot);
    grad.addColorStop(1, lerpColor(blendBot, '#000000', 0.15));
    ctx.fillStyle = grad;
    ctx.fillRect(-20, -20, CW + 40, CH + 40);

    // Aurora/nebula and haze removed for performance

    // Stars for night/space levels (13+) — simplified
    if (level >= 13) {
      var starAlpha = Math.min(1, (level - 12) / 3);
      ctx.globalAlpha = starAlpha;
      for (var si = 0; si < 60; si++) {
        var sx = (si * 97 + 13) % CW;
        var sy = (si * 53 + 7) % (CH * 0.7);
        var sFlicker = 0.3 + 0.7 * Math.abs(Math.sin(now * 0.001 + si * 1.7));
        var starSize = 0.8 + (si % 4) * 0.5;
        ctx.fillStyle = 'rgba(255,255,255,' + (sFlicker * 0.7) + ')';
        ctx.beginPath();
        ctx.arc(sx, sy, starSize, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    }


    // Animated background birds (item 5) — day levels
    if (level >= 1 && level <= 8) {
      for (var bi = 0; bi < bgBirds.length; bi++) {
        var bird = bgBirds[bi];
        var wingY = Math.sin(bird.wingPhase) * 5;
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        // Wings
        ctx.beginPath();
        ctx.moveTo(-8, wingY); ctx.quadraticCurveTo(-4, wingY - 4, 0, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(8, wingY); ctx.quadraticCurveTo(4, wingY - 4, 0, 0);
        ctx.stroke();
        // Body dot
        ctx.fillStyle = '#374151';
        ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.restore();
      }
    }
    // Animated shooting stars (item 5) — night/space levels
    if (level >= 13) {
      for (var si2 = 0; si2 < bgShootingStars.length; si2++) {
        var ss = bgShootingStars[si2];
        ctx.save();
        ctx.globalAlpha = ss.life * 0.7;
        // Trail — simple white line
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ss.x, ss.y);
        ctx.lineTo(ss.x - ss.vx * 8, ss.y - ss.vy * 8);
        ctx.stroke();
        // Head
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(ss.x, ss.y, 2, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.restore();
      }
    }

    // Clouds — simplified to 2 ellipses per cloud
    var cloudDefs = [
      { offset: 0, baseY: 50, depth: 0.3, scale: 0.8 },
      { offset: 190, baseY: 115, depth: 0.5, scale: 1.0 },
      { offset: 380, baseY: 180, depth: 0.7, scale: 1.1 },
      { offset: 570, baseY: 245, depth: 0.9, scale: 1.2 },
      { offset: 760, baseY: 310, depth: 1.0, scale: 1.0 }
    ];
    for (var i = 0; i < cloudDefs.length; i++) {
      var cd = cloudDefs[i];
      var cx = ((cd.offset + now * 0.00006 * 30 * cd.depth) % (CW + 200)) - 100;
      var cy = cd.baseY;
      var sc = cd.scale;
      var cloudAlpha = 0.06 + cd.depth * 0.14;
      var isNight = level >= 13;
      var cloudColor = isNight ? 'rgba(180,190,220,' : 'rgba(255,255,255,';
      // Main cloud puff
      ctx.globalAlpha = cloudAlpha;
      ctx.fillStyle = cloudColor + cloudAlpha + ')';
      ctx.beginPath();
      ctx.ellipse(cx + 20 * sc, cy, 40 * sc, 18 * sc, 0, 0, Math.PI * 2);
      ctx.fill();
      // Secondary puff
      ctx.beginPath();
      ctx.ellipse(cx + 45 * sc, cy + 3 * sc, 28 * sc, 14 * sc, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;

    // Ground glow removed for performance

    // Floor shield — simplified
    if (shieldActive && shieldTimeLeft > 0) {
      var shieldAlpha = Math.min(1, shieldTimeLeft / 500);
      var shieldPulse = 0.6 + 0.4 * Math.sin(now * 0.004);
      var shieldX1 = WALL_W + 10;
      var shieldX2 = CW - WALL_W - 10;
      var shieldW = shieldX2 - shieldX1;
      var shieldY = CH - WALL_W - 8;
      var shieldH = 30;
      ctx.save();

      // Simple dome arc
      ctx.globalAlpha = shieldAlpha * 0.15 * shieldPulse;
      ctx.fillStyle = 'rgba(80, 180, 255, 0.4)';
      ctx.beginPath();
      ctx.moveTo(shieldX1, shieldY + 4);
      ctx.quadraticCurveTo(CW / 2, shieldY - shieldH * 1.5, shieldX2, shieldY + 4);
      ctx.closePath();
      ctx.fill();

      // Main energy bar at the base
      ctx.globalAlpha = shieldAlpha * shieldPulse;
      ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(shieldX1, shieldY);
      ctx.lineTo(shieldX2, shieldY);
      ctx.stroke();

      // Shield timer text
      ctx.globalAlpha = shieldAlpha * 0.9;
      ctx.fillStyle = '#d0f0ff';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u{1F6E1} ' + Math.ceil(shieldTimeLeft / 1000) + 's', CW / 2, shieldY - shieldH - 4);
      ctx.restore();
    }


    // Active power-up effects display with timer bars — glowing and polished
    var effectY = 78;
    var effectBarW = 60;
    var effectBarH = 5;
    var puSlots = [];
    if (activeEffects.shield > 0) puSlots.push({ label: '\u25C8 Shield', time: activeEffects.shield, max: 8000, color: '#60a5fa' });
    if (activeEffects.doubleTokens > 0) puSlots.push({ label: 'x2 Tokens', time: activeEffects.doubleTokens, max: 10000, color: '#fbbf24' });
    if (activeEffects.magnet > 0) puSlots.push({ label: '\uD83E\uDDF2 Magnet', time: activeEffects.magnet, max: 8000, color: '#f472b6' });
    for (var pi = 0; pi < puSlots.length; pi++) {
      var pu = puSlots[pi];
      var puX = CW / 2 + (pi - (puSlots.length - 1) / 2) * 110;

      // Subtle background pill behind each power-up indicator
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = pu.color;
      ctx.beginPath();
      ctx.roundRect(puX - effectBarW / 2 - 6, effectY - 13, effectBarW + 12, effectBarH + 20, 6);
      ctx.fill();

      // Label text with glow
      ctx.globalAlpha = 0.95;
      ctx.shadowColor = pu.color;
      ctx.shadowBlur = 0;
      ctx.fillStyle = pu.color;
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(pu.label + ' ' + Math.ceil(pu.time / 1000) + 's', puX, effectY);
      ctx.shadowBlur = 0;
      // Timer bar background with rounded ends
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath();
      ctx.roundRect(puX - effectBarW / 2, effectY + 3, effectBarW, effectBarH, 2.5);
      ctx.fill();
      // Timer bar fill — flat color
      var barFill = Math.max(0, pu.time / pu.max);
      ctx.fillStyle = pu.color;
      ctx.beginPath();
      ctx.roundRect(puX - effectBarW / 2, effectY + 3, effectBarW * barFill, effectBarH, 2.5);
      ctx.fill();
    }

    // Combo meter bar (progress toward next life)
    if (combo > 0 || lifeFrac > 0) {
      var comboBarX = CW / 2 - 50;
      var comboBarY = 50;
      var comboBarW = 100;
      var comboBarH = 6;
      var comboNeededBar = Math.max(2, 4 - upgrades.fasterCombo.level - (skillTree.speed[0].owned ? 1 : 0));
      var comboFill = combo / comboNeededBar;
      ctx.globalAlpha = 0.7;
      // Background
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.beginPath();
      ctx.roundRect(comboBarX, comboBarY, comboBarW, comboBarH, 3);
      ctx.fill();
      // Fill — flat color
      ctx.fillStyle = '#f472b6';
      ctx.beginPath();
      ctx.roundRect(comboBarX, comboBarY, comboBarW * comboFill, comboBarH, 3);
      ctx.fill();
      // Life recovery dots
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#fff';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('LIFE RECOVERY', CW / 2, comboBarY - 2);
      // Combo count numbers below bar
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(combo + '/' + comboNeededBar, CW / 2, comboBarY + comboBarH + 11);
      ctx.globalAlpha = 1.0;
    }
    ctx.globalAlpha = 1.0;

    // WALLS
    var wallW = 12;

    // Floor — flat fill
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(0, CH - wallW, CW, wallW);
    // Floor shine line
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(0, CH - wallW, CW, 2);

    // Parallax foreground elements — simplified silhouettes
    for (var fgi = 0; fgi < foregroundElements.length; fgi++) {
      var fe = foregroundElements[fgi];
      var feX = ((fe.x + now * 0.00003 * fe.depth * 30) % (CW + 40)) - 20;
      var feY = CH - wallW;
      var isNight = level >= 13;
      ctx.globalAlpha = 0.18 + fe.depth * 0.12;
      if (fe.type === 'grass') {
        // Simple triangle grass
        ctx.fillStyle = isNight ? '#1a2a1a' : '#2d5016';
        ctx.beginPath();
        ctx.moveTo(feX, feY);
        ctx.lineTo(feX + fe.width * 0.5, feY - fe.height);
        ctx.lineTo(feX + fe.width, feY);
        ctx.closePath();
        ctx.fill();
      } else {
        // Simple building rectangle
        var rw = fe.width * 2;
        var rh = fe.height;
        ctx.fillStyle = isNight ? '#0d0d14' : '#374151';
        ctx.fillRect(feX, feY - rh, rw, rh);
      }
    }
    ctx.globalAlpha = 1.0;

    // Right wall — flat fill
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(CW - wallW, 0, wallW, zone.y);
    ctx.fillRect(CW - wallW, zone.y + zone.h, wallW, CH - zone.y - zone.h);

    // Left wall — flat fill
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(0, 0, wallW, zoneL.y);
    ctx.fillRect(0, zoneL.y + zoneL.h, wallW, CH - zoneL.y - zoneL.h);

    // === SAFE ZONE RENDERING (shared setup) ===
    // Check proximity of objects to safe zones for pulse intensity (item 4)
    var rightZoneProximity = 0;
    var leftZoneProximity = 0;
    for (var pi = 0; pi < objects.length; pi++) {
      var po = objects[pi];
      if (!po.alive) continue;
      // Right zone
      var rdx = (CW - WALL_W) - po.x;
      var rdy = (zone.y + zone.h / 2) - po.y;
      var rdist = Math.sqrt(rdx * rdx + rdy * rdy);
      if (rdist < 200) rightZoneProximity = Math.max(rightZoneProximity, 1 - rdist / 200);
      // Left zone
      var ldx = WALL_W - po.x;
      var ldy = (zoneL.y + zoneL.h / 2) - po.y;
      var ldist = Math.sqrt(ldx * ldx + ldy * ldy);
      if (ldist < 200) leftZoneProximity = Math.max(leftZoneProximity, 1 - ldist / 200);
    }
    var basePulseSpeed = 0.004;
    var rightPulseSpeed = basePulseSpeed + rightZoneProximity * 0.012;
    var leftPulseSpeed = basePulseSpeed + leftZoneProximity * 0.012;
    var rightPulseIntensity = 0.5 + 0.3 * Math.sin(now * rightPulseSpeed) + rightZoneProximity * 0.4;
    var leftPulseIntensity = 0.5 + 0.3 * Math.sin(now * leftPulseSpeed) + leftZoneProximity * 0.4;
    var pulse = 0.5 + 0.3 * Math.sin(now * 0.004);
    var pulse2 = 0.4 + 0.6 * Math.abs(Math.sin(now * 0.003));
    var chevOffset = (now * 0.003) % 20;
    var waveT = now * 0.002;

    // --- Helper: draw one safe zone side ---
    // dir: 1 = right, -1 = left
    function drawSafeZone(zd, dir) {
      var zx = dir === 1 ? CW - wallW : 0;
      var edgeX = dir === 1 ? CW - wallW : wallW;

      // Safe zone colors
      var zoneMainR, zoneHighR, zoneChevHigh;
      if (colorblindMode) {
        zoneMainR = '59, 130, 246';
        zoneHighR = '147, 197, 253';
        zoneChevHigh = '#93c5fd';
      } else {
        zoneMainR = dir === 1 ? '52, 211, 153' : '163, 230, 53';
        zoneHighR = dir === 1 ? '134, 239, 172' : '190, 242, 100';
        zoneChevHigh = dir === 1 ? '#86efac' : '#bef264';
      }

      ctx.save();

      // Solid bar fill
      ctx.fillStyle = 'rgba(' + zoneMainR + ', ' + pulse + ')';
      ctx.fillRect(zx, zd.y, wallW, zd.h);

      // Edge line
      ctx.strokeStyle = 'rgba(' + zoneHighR + ', ' + (0.5 + pulse * 0.5) + ')';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(edgeX, zd.y);
      ctx.lineTo(edgeX, zd.y + zd.h);
      ctx.stroke();

      // Simple chevron arrows (2 instead of 4, no glow)
      ctx.lineCap = 'round';
      for (var ci = 0; ci < 2; ci++) {
        var chevX = edgeX + dir * (-20 + ci * 8);
        var chevAlpha = 0.4 + 0.4 * Math.sin(now * 0.005 + ci * 1.2);
        ctx.globalAlpha = chevAlpha;
        ctx.strokeStyle = zoneChevHigh;
        ctx.lineWidth = 2.5;
        for (var ccy = zd.y + 15; ccy < zd.y + zd.h - 15; ccy += 25) {
          ctx.beginPath();
          ctx.moveTo(chevX - dir * 5, ccy - 6);
          ctx.lineTo(chevX + dir * 4, ccy);
          ctx.lineTo(chevX - dir * 5, ccy + 6);
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1.0;

      // Item 24: High-contrast pattern overlay for safe zones
      if (highContrastMode) {
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        for (var hsy = zd.y; hsy < zd.y + zd.h; hsy += 8) {
          ctx.beginPath();
          ctx.moveTo(zx, hsy);
          ctx.lineTo(zx + wallW, hsy + 4);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      // Label
      ctx.save();
      ctx.translate(edgeX + dir * (-40), zd.y + zd.h / 2);
      ctx.rotate(dir === 1 ? -Math.PI / 2 : Math.PI / 2);
      ctx.fillStyle = zoneChevHigh;
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.9;
      ctx.fillText('SAFE ZONE', 0, 0);
      ctx.globalAlpha = 1.0;
      ctx.restore();

      ctx.restore();
    }

    // Override pulse for proximity-based safe zone glow (item 4)
    var savedPulse = pulse;
    pulse = rightPulseIntensity;
    drawSafeZone(zone, 1);
    pulse = leftPulseIntensity;
    drawSafeZone(zoneL, -1);
    pulse = savedPulse;

    // Golden zone rendering (item 8)
    if (goldenZone) {
      var gzX = goldenZone.side === 'right' ? CW - wallW : 0;
      var gzPulse = 0.5 + 0.5 * Math.sin(now * 0.008);
      var gzAlpha = Math.min(1, goldenZone.timer / 1000); // fade out in last second
      ctx.save();
      ctx.globalAlpha = gzAlpha;
      // Golden glow — flat fill
      ctx.fillStyle = 'rgba(255,215,0,' + (gzPulse * 0.4) + ')';
      ctx.fillRect(gzX, goldenZone.y, wallW, goldenZone.h);
      // Border glow
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(255,215,0,' + (0.6 + gzPulse * 0.4) + ')';
      ctx.lineWidth = 2;
      var gzEdge = goldenZone.side === 'right' ? CW - wallW : wallW;
      ctx.beginPath();
      ctx.moveTo(gzEdge, goldenZone.y);
      ctx.lineTo(gzEdge, goldenZone.y + goldenZone.h);
      ctx.stroke();
      ctx.shadowBlur = 0;
      // Label
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.translate(gzEdge + (goldenZone.side === 'right' ? -20 : 20), goldenZone.y + goldenZone.h / 2);
      ctx.rotate(goldenZone.side === 'right' ? -Math.PI / 2 : Math.PI / 2);
      ctx.fillText('3x GOLDEN', 0, 0);
      ctx.restore();
      // Timer bar
      var gzBarW = goldenZone.h * 0.6;
      var gzBarFill = goldenZone.timer / goldenZone.maxTimer;
      ctx.fillStyle = 'rgba(255,215,0,0.2)';
      ctx.fillRect(gzEdge + (goldenZone.side === 'right' ? -35 : 15), goldenZone.y + goldenZone.h - 6, gzBarW, 3);
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(gzEdge + (goldenZone.side === 'right' ? -35 : 15), goldenZone.y + goldenZone.h - 6, gzBarW * gzBarFill, 3);
      // Golden zone sparkle — twinkling dots around the zone
      for (var gsi = 0; gsi < 5; gsi++) {
        var gsY = goldenZone.y + (goldenZone.h / 6) * (gsi + 0.5);
        var gsXOff = goldenZone.side === 'right' ? -15 - gsi * 5 : wallW + 15 + gsi * 5;
        var gsAlpha = 0.3 + 0.7 * Math.abs(Math.sin(now * 0.006 + gsi * 1.3));
        ctx.globalAlpha = gzAlpha * gsAlpha;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(gzX + gsXOff + Math.sin(now * 0.004 + gsi * 2) * 4, gsY + Math.cos(now * 0.005 + gsi * 1.7) * 3, 1.5 + Math.sin(now * 0.008 + gsi) * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // Item 2: Gravity flip zone rendering
    if (gravityFlipZone) {
      var gfAlpha = Math.min(1, gravityFlipZone.timer / 500);
      var gfPulse = 0.5 + 0.5 * Math.sin(now * 0.008);
      ctx.save();
      ctx.globalAlpha = gfAlpha * 0.25;
      ctx.fillStyle = '#a78bfa';
      ctx.beginPath();
      ctx.arc(gravityFlipZone.x, gravityFlipZone.y, gravityFlipZone.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = gfAlpha * 0.6;
      ctx.strokeStyle = '#c084fc';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(gravityFlipZone.x, gravityFlipZone.y, gravityFlipZone.radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      // Upward arrows
      ctx.fillStyle = '#c084fc';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      for (var ai = 0; ai < 3; ai++) {
        var arrowY = gravityFlipZone.y + 10 - ai * 15 - ((now * 0.03) % 15);
        ctx.globalAlpha = gfAlpha * (0.3 + gfPulse * 0.4);
        ctx.fillText('\u2191', gravityFlipZone.x + (ai - 1) * 15, arrowY);
      }
      ctx.globalAlpha = gfAlpha * 0.7;
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText('GRAVITY FLIP', gravityFlipZone.x, gravityFlipZone.y + gravityFlipZone.radius + 14);
      ctx.restore();
    }

    // Item 8: Portal pairs rendering
    for (var ppi2 = 0; ppi2 < portalPairs.length; ppi2++) {
      var pp2 = portalPairs[ppi2];
      var ppPulse = 0.6 + 0.4 * Math.sin(now * 0.006 + ppi2);
      // Entry portal (blue) — simplified
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = 'rgba(96,165,250,0.4)';
      ctx.beginPath(); ctx.arc(pp2.entry.x, pp2.entry.y, 18, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pp2.entry.x, pp2.entry.y, 18 + ppPulse * 3, now * 0.003, now * 0.003 + Math.PI * 1.5);
      ctx.stroke();
      // Exit portal (orange) — simplified
      ctx.fillStyle = 'rgba(251,146,60,0.4)';
      ctx.beginPath(); ctx.arc(pp2.exit.x, pp2.exit.y, 18, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#fb923c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(pp2.exit.x, pp2.exit.y, 18 + ppPulse * 3, -now * 0.003, -now * 0.003 + Math.PI * 1.5);
      ctx.stroke();
      ctx.restore();
    }
    // Pending entry portal
    if (portalPendingEntry) {
      ctx.save();
      ctx.globalAlpha = 0.4 + 0.3 * Math.sin(now * 0.008);
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.arc(portalPendingEntry.x, portalPendingEntry.y, 20, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#60a5fa';
      ctx.font = 'bold 9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('ENTRY', portalPendingEntry.x, portalPendingEntry.y + 28);
      ctx.restore();
    }

    // Item 17: Screen colour shifts based on combo multiplier
    if (comboMultiplier >= 2 && comboMultiplierDisplay > 0) {
      ctx.save();
      var comboOverlayColor = comboMultiplier >= 4 ? 'rgba(255,215,0,' : comboMultiplier >= 3 ? 'rgba(255,60,0,' : 'rgba(255,140,0,';
      ctx.globalAlpha = 0.05 + (comboMultiplier - 1) * 0.02;
      ctx.fillStyle = comboOverlayColor + '1)';
      ctx.fillRect(0, 0, CW, CH);
      ctx.restore();
    }

    // MATTRESS LINES (with selectable color, item 12)
    var lc = lineColors[selectedLineColor] || lineColors[0];
    // Item 24: High-contrast mode — lines always white with black outline
    if (highContrastMode) {
      lc = { main: '#ffffff', glow: '#ffffff', inner: '#ffffff' };
    }
    var lineThickness = 10 + upgrades.widerLines.level * 2 + (skillTree.control[0].owned ? 3 : 0);
    // Curved lines are thicker (item 6)
    if (activeLineType === 'curvedLines') lineThickness += 4;
    for (var i = 0; i < lines.length; i++) {
      var L = lines[i];
      // Fade out over last 0.5 second of line life
      var lineAge = now2 - L.born;
      var lineLifeFade = lineLifeMs || 2000;
      var lineFade = lineAge > (lineLifeFade - 500) ? Math.max(0, 1 - (lineAge - (lineLifeFade - 500)) / 500) : 1;
      // Item 24: High-contrast black outline for lines
      if (highContrastMode) {
        ctx.globalAlpha = lineFade;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = lineThickness + 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(L.x1, L.y1);
        ctx.lineTo(L.x2, L.y2);
        ctx.stroke();
      }
      // Main line
      ctx.globalAlpha = lineFade;
      ctx.strokeStyle = lc.main;
      ctx.lineWidth = lineThickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      if (activeLineType === 'curvedLines') {
        var midX = (L.x1 + L.x2) / 2;
        var midY = (L.y1 + L.y2) / 2 - 15;
        ctx.moveTo(L.x1, L.y1);
        ctx.quadraticCurveTo(midX, midY, L.x2, L.y2);
      } else {
        ctx.moveTo(L.x1, L.y1);
        ctx.lineTo(L.x2, L.y2);
      }
      ctx.stroke();
      // Conveyor line arrow visual
      if (activeLineType === 'conveyorLines') {
        ctx.globalAlpha = lineFade * 0.6;
        var cLx = L.x2 - L.x1, cLy = L.y2 - L.y1;
        var cLen = Math.sqrt(cLx * cLx + cLy * cLy);
        if (cLen > 20) {
          var cAngle = Math.atan2(cLy, cLx);
          var arrowSpacing = 20;
          var arrowOffset = (now * 0.003) % arrowSpacing;
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 2;
          for (var ai2 = arrowOffset; ai2 < cLen; ai2 += arrowSpacing) {
            var ax = L.x1 + (cLx / cLen) * ai2;
            var ay = L.y1 + (cLy / cLen) * ai2;
            ctx.save();
            ctx.translate(ax, ay);
            ctx.rotate(cAngle);
            ctx.beginPath();
            ctx.moveTo(-4, -3); ctx.lineTo(2, 0); ctx.lineTo(-4, 3);
            ctx.stroke();
            ctx.restore();
          }
        }
      }
      // Inner highlight
      ctx.globalAlpha = lineFade * 0.7;
      ctx.strokeStyle = lc.inner;
      ctx.lineWidth = 3;
      ctx.beginPath();
      if (activeLineType === 'curvedLines') {
        var midX2 = (L.x1 + L.x2) / 2;
        var midY2 = (L.y1 + L.y2) / 2 - 15;
        ctx.moveTo(L.x1, L.y1);
        ctx.quadraticCurveTo(midX2, midY2, L.x2, L.y2);
      } else {
        ctx.moveTo(L.x1, L.y1);
        ctx.lineTo(L.x2, L.y2);
      }
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }

    // DRAWING PREVIEW
    if (dragging) {
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = lc.main;
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(dragX1, dragY1);
      ctx.lineTo(dragX2, dragY2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1.0;
    }

    // Object preview — silhouette at top of screen (item 11)
    if (nextSpawnReady && spawnPauseTimer <= 0) {
      ctx.save();
      ctx.globalAlpha = 0.15 + 0.1 * Math.sin(now * 0.005);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(nextSpawnX - 8, 8);
      ctx.lineTo(nextSpawnX + 8, 8);
      ctx.lineTo(nextSpawnX, 22);
      ctx.closePath();
      ctx.fill();
      // Small circle indicator
      ctx.beginPath();
      ctx.arc(nextSpawnX, 4, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Magnet effect visual (item 9) — simplified flat tint
    if (activeEffects.magnet > 0) {
      var zR = getZone();
      var zL = getZoneLeft();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = 'rgba(244,114,182,0.3)';
      ctx.fillRect(CW - WALL_W - 80, zR.y - 20, 100, zR.h + 40);
      ctx.fillRect(-20, zL.y - 20, WALL_W + 100, zL.h + 40);
      ctx.globalAlpha = 1.0;
    }

    // DROP SHADOWS on floor — dynamic based on height
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (!obj.alive) continue;
      if (obj.catching) continue;
      var floorY = CH - wallW - 2;
      var distToFloor = floorY - obj.y;
      if (distToFloor > 0 && distToFloor < CH) {
        var shadowScale = 0.5 + (obj.y / CH) * 0.5;
        var shadowOffX = 3 * shadowScale;
        var shadowAlpha = Math.max(0, 0.25 - distToFloor * 0.0004) * shadowScale;
        var shadowWidth = (12 + (1 - distToFloor / CH) * 10) * (0.8 + shadowScale * 0.4);
        ctx.globalAlpha = shadowAlpha;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(obj.x + shadowOffX, floorY, shadowWidth, 3, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1.0;


    // OBJECTS
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (!obj.alive && !(obj.catching && obj.catchTimer > 0)) continue;

      ctx.save();
      ctx.translate(obj.x, obj.y);
      // Object entrance animation (item 18) — fade in + scale up
      var spawnAge = Date.now() - (obj.spawnTime || 0);
      var entranceT = Math.min(1, spawnAge / 300);
      if (entranceT < 1) {
        ctx.globalAlpha = entranceT;
        var entranceScale = 0.5 + entranceT * 0.5;
        ctx.scale(entranceScale, entranceScale);
      }
      // Apply catch animation scale
      if (obj.catching && obj.catchScale !== undefined) {
        ctx.globalAlpha = obj.catchScale;
        ctx.scale(obj.catchScale, obj.catchScale);
      }
      // Object-specific idle animations (item 2)
      if (obj.type === 'egg' && !obj.catching) {
        // Egg wobble side to side
        var wobble = Math.sin(now * 0.006 + obj.x * 0.01) * 0.08;
        ctx.rotate(wobble);
      }
      // Small split objects (item 10) render at 60% size
      if (obj.small) {
        ctx.scale(0.6, 0.6);
      }
      // Item 9: Shrink ray — render 50% smaller with pulse
      if (obj.shrunk) {
        var shrinkPulse = 0.5 + 0.03 * Math.sin(now * 0.015);
        ctx.scale(shrinkPulse, shrinkPulse);
      }
      // Item 14: Boss objects render at 2x size
      if (obj.isBoss) {
        ctx.scale(2, 2);
      }
      ctx.rotate(obj.rot || 0);
      ctx.scale(obj.squashX || 1, obj.squashY || 1);

      if (obj.type === 'powerup') {
        // Power-up orb — simplified to colored circle + icon
        var puColor = obj.powerup === 'shield' ? '#60a5fa' : obj.powerup === 'magnet' ? '#f472b6' : obj.powerup === 'shrinkRay' ? '#c084fc' : '#fbbf24';
        var puColorDark = obj.powerup === 'shield' ? '#1e3a8a' : obj.powerup === 'magnet' ? '#831843' : obj.powerup === 'shrinkRay' ? '#4c1d95' : '#78350f';

        // Main orb — simple filled circle
        ctx.globalAlpha = 1;
        ctx.fillStyle = puColorDark;
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = puColor;
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.fill();

        // Specular highlight
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-4, -5, 4, 2.5, -0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
        // Icon
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        if (obj.powerup === 'shield') ctx.fillText('\u25C8', 0, 5);
        else if (obj.powerup === 'magnet') ctx.fillText('M', 0, 5);
        else if (obj.powerup === 'shrinkRay') ctx.fillText('\u2B07', 0, 5);
        else ctx.fillText('x2', 0, 5);
      } else if (obj.type === 'egg') {
        // Golden egg — removed orbiting sparkles for performance
        if (obj.golden) {
        }
        // Soft drop shadow underneath
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.ellipse(2, 18, 10, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Egg body — simplified gradient (3 stops)
        var eggGrad = ctx.createRadialGradient(-5, -7, 1, 2, 3, 20);
        if (obj.golden) {
          eggGrad.addColorStop(0, '#ffe580');
          eggGrad.addColorStop(0.5, '#e6a200');
          eggGrad.addColorStop(1, '#7a4e00');
        } else {
          eggGrad.addColorStop(0, '#fefaf0');
          eggGrad.addColorStop(0.5, '#efd8b0');
          eggGrad.addColorStop(1, '#c4956a');
        }
        ctx.beginPath();
        ctx.ellipse(0, 0, 13, 17, 0, 0, Math.PI * 2);
        ctx.fillStyle = eggGrad;
        ctx.fill();
        // Subtle stroke — thinner for porcelain feel
        ctx.strokeStyle = obj.golden ? 'rgba(120,80,0,0.6)' : 'rgba(160,120,80,0.4)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        // Specular highlight
        ctx.beginPath();
        ctx.ellipse(-4, -9, 3.5, 5, -0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();
        if (obj.golden) ctx.shadowBlur = 0;
      } else if (obj.type === 'meteor') {
        // Hyper-realistic meteor rendering
        var mSpeed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) || 1;
        var tdx = -obj.vx / mSpeed;
        var tdy = -obj.vy / mSpeed;
        var mp = 0.5 + 0.5 * Math.abs(Math.sin(now * 0.006));

        // === ATMOSPHERIC ENTRY HEAT GLOW (outermost layer) ===
        // Faint wide plasma wake — the heated air column behind the meteor
        ctx.globalAlpha = 0.08 + mp * 0.04;
        var plasmaGrad = ctx.createRadialGradient(tdx * 20, tdy * 20, 0, tdx * 20, tdy * 20, 55);
        plasmaGrad.addColorStop(0, 'rgba(255, 120, 40, 0.3)');
        plasmaGrad.addColorStop(0.5, 'rgba(180, 40, 10, 0.1)');
        plasmaGrad.addColorStop(1, 'rgba(80, 10, 0, 0)');
        ctx.fillStyle = plasmaGrad;
        ctx.beginPath();
        ctx.ellipse(tdx * 20, tdy * 20, 22, 50, Math.atan2(tdy, tdx), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // === SMOKE / DEBRIS TRAIL (outermost, farthest back) ===
        // Wispy grey-brown smoke that dissipates — realistic ablation debris
        for (var si = 0; si < 8; si++) {
          var st = (si + ((now * 0.003 + si * 0.17) % 1)) / 8;
          var smokeX = tdx * (35 + st * 50) + Math.sin(now * 0.004 + si * 2.7) * st * 12;
          var smokeY = tdy * (35 + st * 50) + Math.cos(now * 0.005 + si * 1.9) * st * 10;
          var smokeR = st * 6 + 2;
          var smokeA = (1 - st) * 0.15;
          ctx.fillStyle = 'rgba(80, 60, 50, ' + smokeA + ')';
          ctx.beginPath();
          ctx.arc(smokeX, smokeY, smokeR, 0, Math.PI * 2);
          ctx.fill();
        }

        // === FIRE TRAIL — layered with turbulence for realism ===
        // Layer 1: Deep red / dark fire (outermost flame)
        for (var ti = 0; ti < 16; ti++) {
          var tt = (ti + ((now * 0.007) % 1)) / 16;
          // Turbulent displacement — each particle drifts differently
          var turb1 = Math.sin(now * 0.009 + ti * 2.3 + tt * 5) * tt * 8;
          var turb2 = Math.cos(now * 0.011 + ti * 1.7 + tt * 4) * tt * 7;
          var trX = tdx * (16 + tt * 55) + turb1;
          var trY = tdy * (16 + tt * 55) + turb2;
          var trR = (1 - tt * tt) * 9;
          var r = Math.floor(160 + tt * 40);
          var g = Math.floor(20 + tt * 20);
          ctx.fillStyle = 'rgba(' + r + ',' + g + ',5,' + ((1 - tt) * 0.45) + ')';
          ctx.beginPath();
          ctx.arc(trX, trY, trR, 0, Math.PI * 2);
          ctx.fill();
        }
        // Layer 2: Bright orange core fire
        for (var ti = 0; ti < 12; ti++) {
          var tt = (ti + ((now * 0.009) % 1)) / 12;
          var turb1 = Math.sin(now * 0.013 + ti * 1.9) * tt * 5;
          var turb2 = Math.cos(now * 0.01 + ti * 2.5) * tt * 4;
          var trX = tdx * (12 + tt * 35) + turb1;
          var trY = tdy * (12 + tt * 35) + turb2;
          var trR = (1 - tt) * 6.5;
          var g = Math.floor(80 + (1 - tt) * 100);
          ctx.fillStyle = 'rgba(255,' + g + ',10,' + ((1 - tt) * 0.55) + ')';
          ctx.beginPath();
          ctx.arc(trX, trY, trR, 0, Math.PI * 2);
          ctx.fill();
        }
        // Layer 3: White-yellow superheated core trail
        for (var ti = 0; ti < 8; ti++) {
          var tt = (ti + ((now * 0.011) % 1)) / 8;
          var turb1 = Math.sin(now * 0.015 + ti * 3.1) * tt * 2.5;
          var turb2 = Math.cos(now * 0.013 + ti * 2.1) * tt * 2;
          var trX = tdx * (8 + tt * 20) + turb1;
          var trY = tdy * (8 + tt * 20) + turb2;
          var trR = (1 - tt) * 4;
          var rr = Math.floor(255);
          var gg = Math.floor(220 + (1 - tt) * 35);
          var bb = Math.floor(120 + (1 - tt) * 100);
          ctx.fillStyle = 'rgba(' + rr + ',' + gg + ',' + bb + ',' + ((1 - tt) * 0.7) + ')';
          ctx.beginPath();
          ctx.arc(trX, trY, trR, 0, Math.PI * 2);
          ctx.fill();
        }

        // === FLYING SPARKS & EMBERS (ablation particles) ===
        for (var ei = 0; ei < 10; ei++) {
          var et = ((now * 0.005 + ei * 0.29) % 1);
          var eAng = (ei * 137.508 % 360) * Math.PI / 180;
          var eDrift = 8 + et * 18;
          var ex = tdx * (12 + et * 40) + Math.sin(eAng + now * 0.004) * eDrift;
          var ey = tdy * (12 + et * 40) + Math.cos(eAng + now * 0.005) * eDrift;
          var eA = (1 - et) * 0.9;
          var eSize = 0.5 + (1 - et) * 1.8;
          // Sparks transition from white-hot to orange to red as they cool
          var sparkR = 255;
          var sparkG = Math.floor(255 - et * 200);
          var sparkB = Math.floor(200 - et * 200);
          ctx.fillStyle = 'rgba(' + sparkR + ',' + Math.max(0, sparkG) + ',' + Math.max(0, sparkB) + ',' + eA + ')';
          ctx.beginPath();
          ctx.arc(ex, ey, eSize, 0, Math.PI * 2);
          ctx.fill();
        }

        // === HEAT DISTORTION AURA (superheated air around rock) ===
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 0;
        // Layered glow: white-hot center → orange → dark red edge
        var heatGrad = ctx.createRadialGradient(0, -1, 2, 0, 0, 22);
        heatGrad.addColorStop(0, 'rgba(255, 255, 220, 0.6)');
        heatGrad.addColorStop(0.15, 'rgba(255, 230, 120, 0.5)');
        heatGrad.addColorStop(0.35, 'rgba(255, 160, 30, 0.35)');
        heatGrad.addColorStop(0.6, 'rgba(220, 60, 5, 0.15)');
        heatGrad.addColorStop(1, 'rgba(120, 10, 0, 0)');
        ctx.fillStyle = heatGrad;
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // === LEADING EDGE BOW SHOCK (compressed air glow in front) ===
        var bowAng = Math.atan2(-tdy, -tdx);
        ctx.strokeStyle = 'rgba(255, 200, 100, ' + (0.2 + mp * 0.15) + ')';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(0, 0, 16, bowAng - 0.8, bowAng + 0.8);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255, 255, 200, ' + (0.12 + mp * 0.1) + ')';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 19, bowAng - 0.5, bowAng + 0.5);
        ctx.stroke();

        // === ROCK CORE — realistic irregular asteroid ===
        // Multi-tone rock with realistic surface shading
        var rockGrad = ctx.createRadialGradient(-4, -4, 1, 1, 1, 14);
        rockGrad.addColorStop(0, '#5a4035');
        rockGrad.addColorStop(0.2, '#4a3025');
        rockGrad.addColorStop(0.5, '#3a201a');
        rockGrad.addColorStop(0.8, '#2a1510');
        rockGrad.addColorStop(1, '#1a0a05');
        ctx.fillStyle = rockGrad;
        // Irregular, jagged asteroid shape
        ctx.beginPath();
        ctx.moveTo(-1, -13);
        ctx.lineTo(5, -12);
        ctx.lineTo(9, -9);
        ctx.lineTo(12, -4);
        ctx.lineTo(13, 1);
        ctx.lineTo(11, 6);
        ctx.lineTo(8, 10);
        ctx.lineTo(4, 12);
        ctx.lineTo(-2, 13);
        ctx.lineTo(-7, 11);
        ctx.lineTo(-11, 7);
        ctx.lineTo(-13, 2);
        ctx.lineTo(-12, -4);
        ctx.lineTo(-10, -8);
        ctx.lineTo(-6, -12);
        ctx.closePath();
        ctx.fill();

        // Surface texture — subtle crater dimples
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath(); ctx.arc(-4, -3, 3.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(5, 4, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(-1, 7, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, -4, 1.8, 0, Math.PI * 2); ctx.fill();
        // Crater rims (lighter edge)
        ctx.fillStyle = 'rgba(120, 90, 70, 0.15)';
        ctx.beginPath(); ctx.arc(-4, -4, 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(5, 3, 3, 0, Math.PI * 2); ctx.fill();

        // Molten cracks — glowing lava veins from reentry heat
        ctx.lineWidth = 1.8;
        ctx.lineCap = 'round';
        var crackGlow = 0.5 + mp * 0.5;
        // Main fissure
        ctx.strokeStyle = 'rgba(255, 180, 40, ' + crackGlow + ')';
        ctx.shadowColor = 'rgba(255, 140, 20, 0.6)';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(-9, -3); ctx.lineTo(-5, 0); ctx.lineTo(-1, -2); ctx.lineTo(3, 1); ctx.lineTo(7, -1);
        ctx.stroke();
        // Secondary fissure
        ctx.strokeStyle = 'rgba(255, 140, 20, ' + (crackGlow * 0.8) + ')';
        ctx.beginPath();
        ctx.moveTo(-3, 3); ctx.lineTo(1, 6); ctx.lineTo(5, 4); ctx.lineTo(9, 7);
        ctx.stroke();
        // Tertiary (thin)
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(255, 200, 80, ' + (crackGlow * 0.7) + ')';
        ctx.beginPath();
        ctx.moveTo(-1, -9); ctx.lineTo(1, -4); ctx.lineTo(-2, 1);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Molten glow spots at fissure junctions
        var hotSpots = [[-5,0],[3,1],[1,6],[-1,-4]];
        for (var hi = 0; hi < hotSpots.length; hi++) {
          var hPulse = 0.35 + 0.45 * Math.sin(now * 0.009 + hi * 1.8);
          // Inner white-hot core
          ctx.fillStyle = 'rgba(255, 255, 180, ' + (hPulse * 0.6) + ')';
          ctx.beginPath(); ctx.arc(hotSpots[hi][0], hotSpots[hi][1], 1.5, 0, Math.PI * 2); ctx.fill();
          // Outer orange glow
          ctx.fillStyle = 'rgba(255, 160, 40, ' + (hPulse * 0.3) + ')';
          ctx.beginPath(); ctx.arc(hotSpots[hi][0], hotSpots[hi][1], 3.5, 0, Math.PI * 2); ctx.fill();
        }

        // Leading edge heating — the front of the rock glows brightest
        var frontX = -tdx * 8;
        var frontY = -tdy * 8;
        var frontGrad = ctx.createRadialGradient(frontX, frontY, 0, frontX, frontY, 10);
        frontGrad.addColorStop(0, 'rgba(255, 240, 180, 0.25)');
        frontGrad.addColorStop(0.5, 'rgba(255, 160, 60, 0.1)');
        frontGrad.addColorStop(1, 'rgba(255, 100, 20, 0)');
        ctx.fillStyle = frontGrad;
        ctx.beginPath();
        ctx.arc(frontX, frontY, 10, 0, Math.PI * 2);
        ctx.fill();
      } else if (obj.type === 'bouncyBall') {
        // Glass marble — simplified
        // Base sphere — flat amber
        ctx.fillStyle = '#c87828';
        ctx.beginPath();
        ctx.arc(0, 0, 13, 0, Math.PI * 2);
        ctx.fill();
        // Edge highlight
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 12.5, 0, Math.PI * 2);
        ctx.stroke();
        // Specular highlight
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath();
        ctx.ellipse(-4, -5, 3, 4, -0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Item 6: Wind-up object rendering — simplified
      if (obj.isWindUp && obj.type === 'windUp') {
        // Toy body — flat color
        ctx.fillStyle = '#e8a020';
        ctx.beginPath();
        ctx.arc(0, 2, 12, 0, Math.PI * 2);
        ctx.fill();
        // Outline
        ctx.strokeStyle = 'rgba(100,60,10,0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 2, 12, 0, Math.PI * 2);
        ctx.stroke();
        // Feet — flat color
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(-9, 12, 6, 5);
        ctx.fillRect(3, 12, 6, 5);
        // Eyes
        ctx.fillStyle = '#1a202e';
        ctx.beginPath(); ctx.arc(-4, -1, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -1, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(-3.2, -2, 0.9, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(4.8, -2, 0.9, 0, Math.PI * 2); ctx.fill();
        // Key on top — simplified flat rectangles
        ctx.save();
        ctx.translate(0, -12);
        ctx.rotate(now * 0.01);
        ctx.fillStyle = '#a0aec0';
        ctx.fillRect(-2, -9, 4, 9);
        ctx.fillRect(-5, -10, 10, 3.5);
        ctx.restore();
        // Specular highlight on body
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.beginPath(); ctx.ellipse(-4, -4, 3.5, 4.5, -0.3, 0, Math.PI * 2); ctx.fill();
      }

      // Item 10: Decoy object rendering (looks like egg but translucent)
      if (obj.isDecoy) {
        ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.5;
        // Same as egg rendering but faded
        ctx.beginPath();
        ctx.ellipse(0, 0, 13, 17, 0, 0, Math.PI * 2);
        var decoyGrad = ctx.createRadialGradient(-4, -6, 2, 0, 0, 18);
        decoyGrad.addColorStop(0, '#fef3c7');
        decoyGrad.addColorStop(1, '#d4a574');
        ctx.fillStyle = decoyGrad;
        ctx.fill();
        ctx.strokeStyle = '#c4956a';
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
        // Question mark
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('?', 0, 5);
      }

      // Item 14: Boss HP bar and label
      if (obj.isBoss && obj.bossHP > 0) {
        ctx.save();
        // Undo the 2x scale for HP bar so it's readable
        ctx.scale(0.5, 0.5);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS!', 0, -45);
        // HP bar
        var hpW = 40, hpH = 5;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(-hpW / 2, -40, hpW, hpH);
        ctx.fillStyle = '#f87171';
        ctx.fillRect(-hpW / 2, -40, hpW * (obj.bossHP / obj.bossMaxHP), hpH);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-hpW / 2, -40, hpW, hpH);
        ctx.restore();
      }


      // Item 12: Egg skins
      if (obj.type === 'egg' && !obj.golden && !obj.isDecoy && !obj._mergedBonus && activeEggSkin !== 'default') {
        if (activeEggSkin === 'galaxy') {
          // Purple overlay with star dots
          ctx.globalAlpha = 0.4;
          ctx.fillStyle = '#6b21a8';
          ctx.beginPath();
          ctx.ellipse(0, 0, 12, 16, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 0.8;
          ctx.fillStyle = '#fff';
          for (var si3 = 0; si3 < 5; si3++) {
            var sax = (si3 * 7 - 14) % 10;
            var say = (si3 * 5 - 8) % 12;
            ctx.beginPath(); ctx.arc(sax, say, 1, 0, Math.PI * 2); ctx.fill();
          }
        } else if (activeEggSkin === 'goldenSkin') {
          // Shiny gold overlay
          ctx.globalAlpha = 0.3;
          var gsGrad = ctx.createRadialGradient(-3, -5, 1, 0, 0, 16);
          gsGrad.addColorStop(0, '#ffd700');
          gsGrad.addColorStop(1, '#b8860b');
          ctx.fillStyle = gsGrad;
          ctx.beginPath();
          ctx.ellipse(0, 0, 12, 16, 0, 0, Math.PI * 2);
          ctx.fill();
        } else if (activeEggSkin === 'neon') {
          // Bright green glow
          ctx.shadowColor = '#22c55e';
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#22c55e';
          ctx.beginPath();
          ctx.ellipse(0, 0, 14, 18, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
      }

      // Item 24: High-contrast colorblind patterns
      if (highContrastMode && obj.type !== 'powerup') {
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        if (obj.type === 'egg') {
          // Dots pattern
          for (var hci = 0; hci < 5; hci++) {
            ctx.beginPath();
            ctx.arc((hci - 2) * 5, (hci % 2) * 6 - 3, 1.5, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if (obj.type === 'meteor') {
          // Zigzag
          ctx.beginPath();
          ctx.moveTo(-8, -5);
          for (var hcz = 0; hcz < 4; hcz++) {
            ctx.lineTo(-8 + hcz * 5, hcz % 2 === 0 ? 5 : -5);
          }
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }


      ctx.restore();
    }

    // BOUNCE FLASHES — simplified to single circle
    for (var i = 0; i < flashes.length; i++) {
      var fl = flashes[i];
      var flR = fl.size * fl.life;
      ctx.globalAlpha = fl.life * 0.5;
      ctx.fillStyle = 'rgba(200,180,255,0.6)';
      ctx.beginPath();
      ctx.arc(fl.x, fl.y, flR, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;

    // PARTICLES — simplified (no glow halos, no per-particle gradients, no twinkle)
    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];
      var pAlpha = Math.max(0, p.life);
      if (p.easingType === 1) pAlpha = Math.pow(pAlpha, 0.5);
      else if (p.easingType === 2) pAlpha = Math.pow(pAlpha, 2);
      var ps = Math.max(0.5, p.size * p.life);

      ctx.globalAlpha = pAlpha;
      ctx.fillStyle = p.color || '#fff';

      if (p.shape === 'star') {
        ctx.save();
        ctx.translate(p.x, p.y);
        if (p.rot !== undefined) ctx.rotate(p.rot);
        ctx.beginPath();
        ctx.moveTo(0, -ps);
        ctx.lineTo(ps * 0.3, -ps * 0.3);
        ctx.lineTo(ps, 0);
        ctx.lineTo(ps * 0.3, ps * 0.3);
        ctx.lineTo(0, ps);
        ctx.lineTo(-ps * 0.3, ps * 0.3);
        ctx.lineTo(-ps, 0);
        ctx.lineTo(-ps * 0.3, -ps * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      } else if (p.shape === 'square') {
        ctx.fillRect(p.x - ps / 2, p.y - ps / 2, ps, ps);
      } else if (p.shape === 'triangle') {
        ctx.save();
        ctx.translate(p.x, p.y);
        if (p.rot !== undefined) ctx.rotate(p.rot);
        ctx.beginPath();
        ctx.moveTo(0, -ps);
        ctx.lineTo(ps * 0.87, ps * 0.5);
        ctx.lineTo(-ps * 0.87, ps * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      } else {
        // Circle — simple filled circle
        ctx.beginPath();
        ctx.arc(p.x, p.y, ps, 0, Math.PI * 2);
        ctx.fill();
      }

      if (p.rot !== undefined && p.rotSpeed !== undefined) {
        p.rot += p.rotSpeed;
      }
    }
    ctx.globalAlpha = 1.0;

    // FLOATING TEXTS — simplified (single draw)
    for (var i = 0; i < texts.length; i++) {
      var t = texts[i];
      var tAlpha = Math.max(0, t.life);
      var displaySize = Math.round(t.size * (t.scale || 1));
      ctx.font = 'bold ' + displaySize + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = tAlpha;
      ctx.fillStyle = t.color;
      ctx.fillText(t.t, t.x, t.y);
      // Animate scale toward target
      if (t.scale && t.scale > t.targetScale) {
        t.scale += (t.targetScale - t.scale) * 0.15;
      }
    }
    ctx.globalAlpha = 1.0;

    // Star rating display with spin-in animation
    if (showStarsTimer > 0) {
      showStarsTimer--;
      var starAlpha = showStarsTimer < 30 ? showStarsTimer / 30 : 1;
      ctx.globalAlpha = starAlpha;
      // Scale animation
      var scaleProgress = Math.min(1, (180 - showStarsTimer) / 20);
      var starScale = 1 + (1 - scaleProgress) * 0.5;
      ctx.save();
      ctx.translate(CW / 2, CH / 2 + 50);
      ctx.scale(starScale, starScale);
      ctx.font = 'bold 50px sans-serif';
      ctx.textAlign = 'center';
      // Draw each star with spin-in
      for (var i = 0; i < 3; i++) {
        var starDelay = i * 10;
        var starProgress = Math.min(1, Math.max(0, (180 - showStarsTimer - starDelay) / 15));
        var starRot = (1 - starProgress) * Math.PI * 2;
        ctx.save();
        var starXOffset = (i - 1) * 45;
        ctx.translate(starXOffset, 0);
        ctx.rotate(starRot);
        ctx.scale(starProgress, starProgress);
        ctx.fillStyle = (i < showStars) ? '#fbbf24' : '#666';
        ctx.shadowColor = (i < showStars) ? '#fbbf24' : 'transparent';
        ctx.shadowBlur = 0;
        ctx.fillText((i < showStars) ? '\u2605' : '\u2606', 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
      ctx.restore();
      // Show star bonus
      if (showStarsTimer > 30 && showStarsTimer < 150) {
        ctx.globalAlpha = starAlpha;
        ctx.font = 'bold 18px sans-serif';
        ctx.fillStyle = '#fbbf24';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 0;
        ctx.fillText('+' + (showStars * 5) + ' star bonus!', CW / 2, CH / 2 + 95);
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1.0;
    }

    // Level stars summary (top of screen)
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#fbbf24';
    var starSummary = '';
    for (var i = 0; i < Math.min(level, 20, levelStars.length); i++) {
      var s = levelStars[i];
      starSummary += 'L' + (i + 1) + ':';
      for (var j = 0; j < 3; j++) starSummary += (j < s) ? '\u2605' : '\u2606';
      starSummary += ' ';
    }
    if (starSummary) {
      ctx.fillText(starSummary, 70, 68);
      // Star rating explanation "?" icon
      ctx.fillStyle = 'rgba(251,191,36,0.5)';
      ctx.font = '11px sans-serif';
      var starTextWidth = ctx.measureText(starSummary).width;
      ctx.fillText('(?)', 70 + starTextWidth + 6, 68);
    }

    // Prominent score counter — "Catches: X" near top-center
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Catches: ' + totalCatches, CW / 2, 38);
    ctx.restore();

    // Ambient gameplay vignette removed for performance

    // Level-up screen flash — simplified to flat tint
    if (levelUpFlash > 0) {
      var flashProgress = levelUpFlash / 20;
      ctx.globalAlpha = flashProgress * 0.2;
      ctx.fillStyle = 'rgba(251, 191, 36, 0.5)';
      ctx.fillRect(0, 0, CW, CH);
      levelUpFlash--;
      ctx.globalAlpha = 1.0;
    }

    // Level-up banner — simplified
    if (levelUpBanner > 0) {
      levelUpBanner--;
      var bannerAlpha = levelUpBanner < 20 ? levelUpBanner / 20 : Math.min(1, (120 - levelUpBanner) / 10);
      var bannerScale = 1 + (levelUpBanner > 100 ? (120 - levelUpBanner) / 20 * 0.3 : 0);
      ctx.save();
      ctx.globalAlpha = bannerAlpha;
      ctx.translate(CW / 2, CH / 2 - 30);
      ctx.scale(bannerScale, bannerScale);
      // Banner background — flat
      ctx.fillStyle = 'rgba(30, 15, 0, 0.7)';
      ctx.beginPath();
      ctx.roundRect(-130, -34, 260, 68, 18);
      ctx.fill();
      // Gold border
      ctx.strokeStyle = '#fcd34d';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(-128, -32, 256, 64, 16);
      ctx.stroke();
      // Text
      ctx.fillStyle = '#fef3c7';
      ctx.font = 'bold 34px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('LEVEL ' + levelUpBannerLevel, 0, 12);
      ctx.restore();
    }


    // Near-miss screen edge flash — simplified flat tint
    if (nearMissFlash > 0) {
      ctx.globalAlpha = (nearMissFlash / 15) * 0.15;
      ctx.fillStyle = 'rgba(253, 224, 71, 0.5)';
      ctx.fillRect(0, 0, CW, CH);
      ctx.globalAlpha = 1.0;
      nearMissFlash--;
    }

    // Combo flash tint overlay (item 4 visual)
    if (comboFlashTimer > 0) {
      ctx.save();
      ctx.globalAlpha = (comboFlashTimer / 300) * 0.15;
      ctx.fillStyle = comboFlashColor;
      ctx.fillRect(0, 0, CW, CH);
      ctx.restore();
    }

    // Countdown timer display (item 20)
    if (countdownTimer > 0 && countdownPhase !== 0) {
      ctx.save();
      // Dim background
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, CW, CH);
      ctx.globalAlpha = 1.0;
      // Number or GO
      var countdownText = countdownPhase > 0 ? '' + countdownPhase : 'GO!';
      var countdownColor = countdownPhase > 0 ? '#fff' : '#5eead4';
      // Scale animation within each phase
      var phaseTime;
      if (countdownPhase === 3) phaseTime = (countdownTimer - 2400) / 800;
      else if (countdownPhase === 2) phaseTime = (countdownTimer - 1600) / 800;
      else if (countdownPhase === 1) phaseTime = (countdownTimer - 800) / 800;
      else phaseTime = countdownTimer / 800;
      phaseTime = Math.max(0, Math.min(1, phaseTime));
      var countScale = 0.5 + phaseTime * 0.8;
      ctx.translate(CW / 2, CH / 2);
      ctx.scale(countScale, countScale);
      ctx.globalAlpha = 0.5 + phaseTime * 0.5;
      ctx.fillStyle = countdownColor;
      ctx.font = 'bold 100px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = countdownColor;
      ctx.shadowBlur = 0;
      ctx.fillText(countdownText, 0, 35);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Screen border flash on catch (green) / crash (red)
    if (catchFlashTimer > 0) {
      ctx.save();
      ctx.globalAlpha = (catchFlashTimer / 10) * 0.4;
      ctx.strokeStyle = '#66bb6a';
      ctx.lineWidth = 6;
      ctx.strokeRect(3, 3, CW - 6, CH - 6);
      ctx.restore();
      catchFlashTimer--;
    }
    if (crashFlashTimer > 0) {
      ctx.save();
      ctx.globalAlpha = (crashFlashTimer / 10) * 0.5;
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 8;
      ctx.strokeRect(4, 4, CW - 8, CH - 8);
      ctx.restore();
      crashFlashTimer--;
    }

    // Level transition fade overlay
    if (levelTransitionPhase > 0) {
      ctx.save();
      ctx.globalAlpha = levelTransitionAlpha;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, CW, CH);
      ctx.restore();
    }

    // Encouraging message between levels
    if (levelMessageTimer > 0) {
      levelMessageTimer--;
      var msgAlpha = levelMessageTimer < 20 ? levelMessageTimer / 20 : Math.min(1, (120 - levelMessageTimer) / 15);
      ctx.save();
      ctx.globalAlpha = msgAlpha;
      ctx.fillStyle = '#5eead4';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(levelMessage, CW / 2, CH / 2 + 100);
      ctx.restore();
    }

    // Achievement popup
    if (achievementPopup && achievementPopup.timer > 0) {
      achievementPopup.timer--;
      var apAlpha = achievementPopup.timer < 20 ? achievementPopup.timer / 20 : Math.min(1, (180 - achievementPopup.timer) / 15);
      ctx.save();
      ctx.globalAlpha = apAlpha;
      var apY = 120;
      ctx.fillStyle = 'rgba(30, 30, 60, 0.85)';
      ctx.beginPath();
      ctx.roundRect(CW / 2 - 120, apY - 25, 240, 50, 14);
      ctx.fill();
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#fbbf24';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.roundRect(CW / 2 - 120, apY - 25, 240, 50, 14);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 13px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('ACHIEVEMENT UNLOCKED', CW / 2, apY - 8);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px sans-serif';
      ctx.fillText(achievementPopup.icon + ' ' + achievementPopup.name, CW / 2, apY + 14);
      ctx.restore();
    }

    ctx.restore(); // end screen shake

  } catch(err) {
    errorLog.push(err.message);
  }
}

// Play Again button (item 19)
function playAgain() {
  document.getElementById('gameOverScreen').classList.remove('show');
  lives = maxLives; lifeFrac = 0; strikes = 0; combo = 0; level = 1; totalCatches = 0; bounceCount = 0; catchStreak = 0; wind = 0; levelCrashes = 0; levelBounces = 0; levelTransitionPhase = 0; levelTransitionAlpha = 0; levelTransitionTimer = 0; catchFlashTimer = 0; crashFlashTimer = 0; levelMessageTimer = 0;
  bestStreakThisRun = 0; tokensThisRun = 0;
  activeEffects.shield = 0; activeEffects.slowmo = 0; activeEffects.doubleTokens = 0; activeEffects.magnet = 0;
  comboMultiplier = 1; comboMultiplierTimer = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  timeFreezeTimer = 0; deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000;
  comboFlashTimer = 0; nearMissFlash = 0; lastCatchType = ''; sameTypeComboCount = 0;
  bgBirds = []; bgShootingStars = [];
  objects = []; lines = []; particles = []; texts = [];
  spawnTimer = 100;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  cameraZoom = 1.0; cameraZoomTarget = 1.0; cameraZoomTimer = 0;
  gravityFlipZone = null; portalPairs = []; portalPendingEntry = null;
  shrinkRayTimer = 0; catchSlowmoTimer = 0; catchSlowmoFactor = 1.0;
  safeZonePhase = 0;
  // Countdown timer (item 20)
  countdownTimer = 1600;
  countdownPhase = 3;
  spawnTimer = 5000;
  running = true;
  sessionStartTime = Date.now();
  lastTime = 0;
  document.getElementById('shieldBtn').classList.remove('used');
  updateShieldBtn();
  initAudio();
  startBgMusic();
  updateHUD();
}

// Tutorial multi-step (item 16)
function nextTutorialStep() {
  tutorialStepIdx++;
  if (tutorialStepIdx >= tutorialSteps.length) {
    closeTutorial();
    return;
  }
  var step = tutorialSteps[tutorialStepIdx];
  document.getElementById('tutorialIcon').textContent = step.icon;
  document.getElementById('tutorialTitle').textContent = step.title;
  document.getElementById('tutorialStep').innerHTML = step.text;
  if (tutorialStepIdx === tutorialSteps.length - 1) {
    document.getElementById('tutorialNextBtn').textContent = 'Got it!';
  }
  updateTutorialDots();
}

function updateTutorialDots() {
  var dotsEl = document.getElementById('tutorialDots');
  dotsEl.innerHTML = '';
  for (var i = 0; i < tutorialSteps.length; i++) {
    var dot = document.createElement('div');
    dot.style.cssText = 'width:8px; height:8px; border-radius:50%; background:' + (i <= tutorialStepIdx ? '#5eead4' : 'rgba(255,255,255,0.3)') + ';';
    dotsEl.appendChild(dot);
  }
}

function initTutorialUI() {
  tutorialStepIdx = 0;
  var step = tutorialSteps[0];
  document.getElementById('tutorialIcon').textContent = step.icon;
  document.getElementById('tutorialTitle').textContent = step.title;
  document.getElementById('tutorialStep').innerHTML = step.text;
  document.getElementById('tutorialNextBtn').textContent = 'Next';
  updateTutorialDots();
}

// Stats page (item 17)
function openStats() {
  var s = gameStats;
  document.getElementById('statTotalCatches').textContent = s.totalCatches;
  document.getElementById('statTotalGames').textContent = s.totalGames;
  // Favourite object
  var favType = '-';
  var favCount = 0;
  for (var t in s.catchesByType) {
    if (s.catchesByType[t] > favCount) { favCount = s.catchesByType[t]; favType = t; }
  }
  document.getElementById('statFavObject').textContent = favType;
  document.getElementById('statBestLevelAll').textContent = s.bestLevel;
  var mins = Math.floor(s.totalTimePlayed / 60);
  var hrs = Math.floor(mins / 60);
  document.getElementById('statTotalTime').textContent = hrs > 0 ? hrs + 'h ' + (mins % 60) + 'm' : mins + 'm';
  document.getElementById('statTotalTokensEarned').textContent = s.totalTokensEarned;
  document.getElementById('statsScreen').classList.add('show');
}

function closeStats() {
  document.getElementById('statsScreen').classList.remove('show');
}

// Prestige system (item 14)
function doPrestige() {
  if (bestLevel < 20) {
    showWarning('Reach level 20 first to prestige!');
    return;
  }
  if (confirm('Prestige will reset your level progress and upgrades, but give a permanent ' + ((prestigeLevel + 1) * 10) + '% token multiplier. Continue?')) {
    prestigeLevel++;
    prestigeMultiplier = 1 + prestigeLevel * 0.1;
    // Reset upgrades
    for (var k in upgrades) {
      upgrades[k].level = 0;
      var basePrice = k === 'shieldFloor' ? 50 : k === 'widerZones' ? 100 : k === 'slowerMeteors' ? 80 : k === 'fasterCombo' ? 90 : 75;
      upgrades[k].price = basePrice;
    }
    levelStars = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    bestLevel = 0;
    applyUpgrades();
    checkAchievements(); // check prestige achievement
    saveProgress();
    // Update UI
    for (var k in upgrades) {
      document.getElementById(k + 'Btn').classList.remove('active');
      if (k === 'shieldFloor') {
        document.getElementById(k + 'Lv').textContent = '0s';
      } else {
        document.getElementById(k + 'Lv').textContent = 'Lv:0/10';
      }
      document.getElementById(k + 'Price').textContent = '(' + upgrades[k].price + ')';
    }
    updatePrestigeBtn();
    updateHUD();
    showWarning('Prestiged! Token multiplier: ' + prestigeMultiplier.toFixed(1) + 'x');
  }
}

function updatePrestigeBtn() {
  var btn = document.getElementById('prestigeBtn');
  if (bestLevel >= 20) {
    btn.style.display = 'block';
    var nextMult = (1 + (prestigeLevel + 1) * 0.1).toFixed(1);
    btn.querySelector('button').textContent = '\u2B50 Prestige (' + nextMult + 'x multiplier)';
  } else {
    btn.style.display = 'none';
  }
}

// Line color selector (item 12)
function initLineColorSelector() {
  var container = document.getElementById('lineColorSelector');
  container.innerHTML = '';
  for (var i = 0; i < lineColors.length; i++) {
    var lc = lineColors[i];
    var btn = document.createElement('div');
    btn.className = 'line-color-btn';
    btn.style.background = lc.main;
    btn.dataset.idx = i;
    if (unlockedLineColors.indexOf(i) < 0) {
      btn.classList.add('locked');
      btn.title = 'Unlocks at level ' + lc.unlockLevel;
    } else {
      btn.title = lc.name;
    }
    if (i === selectedLineColor) btn.classList.add('active');
    btn.onclick = function() {
      var idx = parseInt(this.dataset.idx);
      if (unlockedLineColors.indexOf(idx) < 0) {
        showWarning('Reach level ' + lineColors[idx].unlockLevel + ' to unlock!');
        return;
      }
      selectedLineColor = idx;
      saveProgress();
      initLineColorSelector();
    };
    container.appendChild(btn);
  }
}

// ========== NEW FEATURE FUNCTIONS ==========

// Line type shop (item 6)
function buyLineType(type) {
  sfxClick();
  var lt = lineTypeUpgrades[type];
  if (lt.level >= 1) {
    showWarning(lt.name + ' already purchased!');
    return;
  }
  if (fluffTokens >= lt.price) {
    fluffTokens -= lt.price;
    lt.level = 1;
    activeLineType = type;
    saveProgress();
    updateLineTypeShopUI();
    updateSettingsSelectors();
    updateHUD();
  } else {
    showWarning('Need ' + (lt.price - fluffTokens) + ' more tokens!');
  }
}

function updateLineTypeShopUI() {
  for (var k in lineTypeUpgrades) {
    var lt = lineTypeUpgrades[k];
    var btn = document.getElementById(k + 'Btn');
    var priceEl = document.getElementById(k + 'Price');
    if (btn) {
      if (lt.level >= 1) {
        btn.classList.add('active');
        if (priceEl) priceEl.textContent = '(OWNED)';
      } else {
        if (priceEl) priceEl.textContent = '(' + lt.price + ')';
      }
    }
  }
}

function setLineType(type) {
  if (type === 'normal' || (lineTypeUpgrades[type] && lineTypeUpgrades[type].level >= 1) || (type === 'conveyorLines' && conveyorLinesPurchased)) {
    activeLineType = type;
    saveProgress();
  }
}

function updateSettingsSelectors() {
  // Line type select
  var ltSelect = document.getElementById('lineTypeSelect');
  if (ltSelect) {
    ltSelect.innerHTML = '<option value="normal">Normal</option>';
    for (var k in lineTypeUpgrades) {
      if (lineTypeUpgrades[k].level >= 1) {
        var opt = document.createElement('option');
        opt.value = k;
        opt.textContent = lineTypeUpgrades[k].name;
        ltSelect.appendChild(opt);
      }
    }
    ltSelect.value = activeLineType;
  }
  // Bg theme select
  var bgSelect = document.getElementById('bgThemeSelect');
  if (bgSelect) {
    bgSelect.innerHTML = '<option value="default">Default</option>';
    for (var i = 0; i < purchasedBgThemes.length; i++) {
      for (var j = 0; j < bgThemeShop.length; j++) {
        if (bgThemeShop[j].id === purchasedBgThemes[i]) {
          var opt = document.createElement('option');
          opt.value = bgThemeShop[j].id;
          opt.textContent = bgThemeShop[j].name;
          bgSelect.appendChild(opt);
        }
      }
    }
    bgSelect.value = activeBgTheme || 'default';
  }
  // Egg skin select
  var skinSelect = document.getElementById('eggSkinSelect');
  if (skinSelect) {
    skinSelect.innerHTML = '<option value="default">Default</option>';
    for (var i = 0; i < purchasedEggSkins.length; i++) {
      for (var j = 0; j < eggSkins.length; j++) {
        if (eggSkins[j].id === purchasedEggSkins[i]) {
          var opt = document.createElement('option');
          opt.value = eggSkins[j].id;
          opt.textContent = eggSkins[j].name;
          skinSelect.appendChild(opt);
        }
      }
    }
    skinSelect.value = activeEggSkin;
  }
  // Trail select
  var trailSelect = document.getElementById('trailSelect');
  if (trailSelect) {
    trailSelect.innerHTML = '';
    for (var i = 0; i < purchasedTrails.length; i++) {
      for (var j = 0; j < trailEffects.length; j++) {
        if (trailEffects[j].id === purchasedTrails[i]) {
          var opt = document.createElement('option');
          opt.value = trailEffects[j].id;
          opt.textContent = trailEffects[j].name;
          trailSelect.appendChild(opt);
        }
      }
    }
    trailSelect.value = activeTrailEffect;
  }
  // Line type: add conveyor
  var ltSelect2 = document.getElementById('lineTypeSelect');
  if (ltSelect2 && conveyorLinesPurchased) {
    var hasConveyor = false;
    for (var i = 0; i < ltSelect2.options.length; i++) {
      if (ltSelect2.options[i].value === 'conveyorLines') hasConveyor = true;
    }
    if (!hasConveyor) {
      var opt = document.createElement('option');
      opt.value = 'conveyorLines';
      opt.textContent = 'Conveyor Lines';
      ltSelect2.appendChild(opt);
    }
  }
  // One-hand mode toggle
  var ohToggle = document.getElementById('oneHandToggle');
  if (ohToggle) ohToggle.checked = oneHandMode;
  // High contrast toggle
  var hcToggle = document.getElementById('highContrastToggle');
  if (hcToggle) hcToggle.checked = highContrastMode;
  // Difficulty buttons
  var diffBtns = document.querySelectorAll('.diff-btn');
  for (var i = 0; i < diffBtns.length; i++) {
    diffBtns[i].classList.remove('active');
    if (diffBtns[i].textContent.toLowerCase() === gameDifficulty) diffBtns[i].classList.add('active');
  }
}

// Background theme shop (item 12 progression)
function buyBgTheme(themeId) {
  sfxClick();
  if (purchasedBgThemes.indexOf(themeId) >= 0) {
    showWarning('Already purchased!');
    return;
  }
  var theme = null;
  for (var i = 0; i < bgThemeShop.length; i++) {
    if (bgThemeShop[i].id === themeId) { theme = bgThemeShop[i]; break; }
  }
  if (!theme) return;
  if (fluffTokens >= theme.price) {
    fluffTokens -= theme.price;
    purchasedBgThemes.push(themeId);
    activeBgTheme = themeId;
    saveProgress();
    updateBgThemeShopUI();
    updateSettingsSelectors();
    updateHUD();
  } else {
    showWarning('Need ' + (theme.price - fluffTokens) + ' more tokens!');
  }
}

function setBgTheme(val) {
  activeBgTheme = val === 'default' ? null : val;
  saveProgress();
}

function updateBgThemeShopUI() {
  for (var i = 0; i < bgThemeShop.length; i++) {
    var t = bgThemeShop[i];
    var btn = document.getElementById(t.id + 'Btn');
    var priceEl = document.getElementById(t.id + 'Price');
    if (btn && purchasedBgThemes.indexOf(t.id) >= 0) {
      btn.classList.add('active');
      if (priceEl) priceEl.textContent = '(OWNED)';
    }
  }
}

// World Map / Level Select (item 11)
function openWorldMap() {
  var grid = document.getElementById('worldMapGrid');
  grid.innerHTML = '';
  for (var i = 1; i <= 20; i++) {
    var node = document.createElement('div');
    node.className = 'world-map-node';
    var unlocked = (i === 1) || (levelStars[i - 2] > 0);
    if (unlocked) {
      node.classList.add('unlocked');
      node.dataset.level = i;
      node.onclick = function() {
        var lv = parseInt(this.dataset.level);
        startFromLevel(lv);
      };
    } else {
      node.classList.add('locked');
    }
    var stars = levelStars[i - 1] || 0;
    var starStr = '';
    for (var s = 0; s < 3; s++) starStr += s < stars ? '\u2605' : '\u2606';
    node.innerHTML = '<span>' + i + '</span><span class="node-stars">' + starStr + '</span>';
    grid.appendChild(node);
  }
  document.getElementById('worldMapScreen').classList.add('show');
}

function closeWorldMap() {
  document.getElementById('worldMapScreen').classList.remove('show');
}

function startFromLevel(lv) {
  closeWorldMap();
  level = lv;
  totalCatches = (lv - 1) * 3; // set catches so level calc stays correct
  startGame();
}

// Milestone rewards (item 14)
function checkMilestones() {
  for (var i = 0; i < milestoneThresholds.length; i++) {
    if (milestonesCollected.indexOf(i) >= 0) continue;
    if (gameStats.totalCatches >= milestoneThresholds[i]) {
      milestonesCollected.push(i);
      var reward = milestoneRewards[i];
      fluffTokens += reward;
      saveProgress();
      showMilestone(milestoneThresholds[i], reward);
      return; // show one at a time
    }
  }
}

function showMilestone(catches, reward) {
  document.getElementById('milestoneTitle').textContent = '\uD83C\uDFC5 Milestone: ' + catches + ' Catches!';
  document.getElementById('milestoneText').textContent = 'You earned ' + reward + ' bonus tokens!';
  document.getElementById('milestonePopup').classList.add('show');
}

function closeMilestone() {
  document.getElementById('milestonePopup').classList.remove('show');
  updateHUD();
}

// Share Score (item 15)
function shareScore() {
  var starStr = '';
  var lv = parseInt(document.getElementById('goLevel').textContent) || level;
  var stars = levelStars[lv - 1] || 0;
  for (var i = 0; i < stars; i++) starStr += '\u2B50';
  if (stars === 0) starStr = '';
  var text = '\uD83C\uDFAE Plummet Protect: Level ' + lv + ' | Score: ' + (document.getElementById('goCatches').textContent || totalCatches) + ' catches | Combo: ' + (document.getElementById('goStreak').textContent || bestStreakThisRun) + 'x | ' + starStr + ' \u2014 Can you beat me?';
  try {
    navigator.clipboard.writeText(text).then(function() {
      var btn = document.getElementById('shareScoreBtn');
      btn.textContent = '\u2705 Copied!';
      setTimeout(function() { btn.textContent = '\uD83D\uDD17 Share Score'; }, 2000);
    });
  } catch(e) {
    // Fallback
    prompt('Copy this:', text);
  }
}


// Confetti burst for safe zone catches (item 1)
function safeZoneConfetti(x, y) {
  var confettiColors = ['#ff6b6b', '#fbbf24', '#34d399', '#60a5fa', '#a78bfa', '#f472b6', '#22d3ee'];
  for (var i = 0; i < 25; i++) {
    var a = Math.random() * Math.PI * 2;
    var s = 2 + Math.random() * 5;
    particles.push({
      x: x, y: y,
      vx: Math.cos(a) * s,
      vy: Math.sin(a) * s - 3,
      life: 1.2,
      color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
      size: 3 + Math.random() * 4,
      shape: ['square', 'triangle', 'circle', 'star'][Math.floor(Math.random() * 4)],
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.3
    });
  }
}

// Initialize parallax foreground elements (item 3)
function initForeground() {
  foregroundElements = [];
  for (var i = 0; i < 12; i++) {
    foregroundElements.push({
      x: Math.random() * CW,
      type: Math.random() > 0.5 ? 'grass' : 'rooftop',
      height: 8 + Math.random() * 12,
      width: 4 + Math.random() * 8,
      depth: 0.3 + Math.random() * 0.7
    });
  }
}
initForeground();

// Initialize background birds/shooting stars (item 5)
function spawnBgBird() {
  bgBirds.push({
    x: -30,
    y: 40 + Math.random() * (CH * 0.4),
    vx: 0.5 + Math.random() * 1.5,
    wingPhase: Math.random() * Math.PI * 2
  });
}

function spawnShootingStar() {
  bgShootingStars.push({
    x: Math.random() * CW,
    y: Math.random() * (CH * 0.4),
    vx: 3 + Math.random() * 4,
    vy: 1 + Math.random() * 2,
    life: 1.0
  });
}

// Time freeze sound (item 9)
function sfxTimeFreeze() {
  playTone(1500, 0.3, 'sine', 0.08);
  setTimeout(function() { playTone(2000, 0.2, 'sine', 0.06); }, 100);
  setTimeout(function() { playTone(1200, 0.4, 'sine', 0.05); }, 200);
}

// Object split sound (item 10)
function sfxSplit() {
  playTone(800, 0.1, 'sine', 0.08);
  playTone(1200, 0.08, 'triangle', 0.06);
}

// Crowd gasp (item 22)
function sfxCrowdGasp() {
  if (!audioCtx || muted) return;
  try {
    var now = audioCtx.currentTime;
    var volMult = sfxVol * 0.3;
    // Create noise-like gasp using multiple oscillators
    for (var i = 0; i < 4; i++) {
      var osc = audioCtx.createOscillator();
      var gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 200 + Math.random() * 300;
      gain.gain.setValueAtTime(0.02 * volMult, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.15);
    }
  } catch(e) {}
}

// Crowd cheer (item 22)
function sfxCrowdCheer() {
  if (!audioCtx || muted) return;
  try {
    var now = audioCtx.currentTime;
    var volMult = sfxVol * 0.25;
    for (var i = 0; i < 6; i++) {
      var osc = audioCtx.createOscillator();
      var gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 300 + i * 80 + Math.random() * 100;
      osc.frequency.linearRampToValueAtTime(400 + i * 100, now + 0.3);
      gain.gain.setValueAtTime(0.015 * volMult, now);
      gain.gain.linearRampToValueAtTime(0.025 * volMult, now + 0.15);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now + i * 0.02);
      osc.stop(now + 0.4);
    }
  } catch(e) {}
}

// Ambient bird chirp (item 23)
function sfxBirdChirp() {
  if (!audioCtx || muted) return;
  try {
    var now = audioCtx.currentTime;
    var volMult = sfxVol * 0.15;
    var osc = audioCtx.createOscillator();
    var gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(2000 + Math.random() * 1000, now);
    osc.frequency.linearRampToValueAtTime(2500 + Math.random() * 1000, now + 0.05);
    osc.frequency.linearRampToValueAtTime(1800 + Math.random() * 800, now + 0.1);
    gain.gain.setValueAtTime(0.03 * volMult, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.12);
  } catch(e) {}
}

// Ambient cricket sound (item 23)
function sfxCricket() {
  if (!audioCtx || muted) return;
  try {
    var now = audioCtx.currentTime;
    var volMult = sfxVol * 0.1;
    var osc = audioCtx.createOscillator();
    var gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 4000 + Math.random() * 1000;
    gain.gain.setValueAtTime(0, now);
    // Rapid on-off for cricket effect
    for (var i = 0; i < 6; i++) {
      gain.gain.linearRampToValueAtTime(0.02 * volMult, now + i * 0.03 + 0.005);
      gain.gain.linearRampToValueAtTime(0, now + i * 0.03 + 0.02);
    }
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.2);
  } catch(e) {}
}

// Ambient cosmic hum (item 23)
function sfxCosmicHum() {
  if (!audioCtx || muted) return;
  try {
    var now = audioCtx.currentTime;
    var volMult = sfxVol * 0.08;
    var osc = audioCtx.createOscillator();
    var gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 60 + Math.random() * 20;
    gain.gain.setValueAtTime(0.02 * volMult, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 1.5);
    // Harmonic
    var osc2 = audioCtx.createOscillator();
    var gain2 = audioCtx.createGain();
    osc2.type = 'sine';
    osc2.frequency.value = 90 + Math.random() * 15;
    gain2.gain.setValueAtTime(0.01 * volMult, now);
    gain2.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);
    osc2.start(now);
    osc2.stop(now + 1.5);
  } catch(e) {}
}

// ========== NEW FEATURE FUNCTIONS (items 1-24) ==========

// 7. Conveyor lines shop
function buyConveyorLines() {
  sfxClick();
  if (conveyorLinesPurchased) { showWarning('Already purchased!'); return; }
  if (fluffTokens >= 150) {
    fluffTokens -= 150;
    conveyorLinesPurchased = true;
    activeLineType = 'conveyorLines';
    saveProgress();
    updateConveyorShopUI();
    updateSettingsSelectors();
    updateHUD();
  } else {
    showWarning('Need ' + (150 - fluffTokens) + ' more tokens!');
  }
}
function updateConveyorShopUI() {
  var btn = document.getElementById('conveyorLinesBtn');
  if (btn && conveyorLinesPurchased) {
    btn.classList.add('active');
    document.getElementById('conveyorLinesPrice').textContent = '(OWNED)';
  }
}

// 8. Portal pairs shop
function buyPortalUpgrade() {
  sfxClick();
  if (portalUpgradeLevel >= 3) { showWarning('Portal pairs maxed!'); return; }
  if (fluffTokens >= 200) {
    fluffTokens -= 200;
    portalUpgradeLevel++;
    saveProgress();
    document.getElementById('portalPairsLv').textContent = 'Lv:' + portalUpgradeLevel + '/3';
    if (portalUpgradeLevel >= 3) document.getElementById('portalPairsPrice').textContent = '(MAX)';
    updateHUD();
  } else {
    showWarning('Need ' + (200 - fluffTokens) + ' more tokens!');
  }
}

// 11. Skill tree
function renderSkillTree() {
  var container = document.getElementById('skillTreePaths');
  if (!container) return;
  container.innerHTML = '';
  var paths = [
    { key: 'speed', name: 'Speed', color: '#fbbf24', nodes: skillTree.speed },
    { key: 'control', name: 'Control', color: '#60a5fa', nodes: skillTree.control },
    { key: 'luck', name: 'Luck', color: '#a78bfa', nodes: skillTree.luck }
  ];
  for (var pi = 0; pi < paths.length; pi++) {
    var p = paths[pi];
    var pathDiv = document.createElement('div');
    pathDiv.className = 'skill-path';
    var title = document.createElement('div');
    title.className = 'skill-path-title';
    title.style.background = 'rgba(' + hexToRgb(p.color) + ',0.15)';
    title.style.color = p.color;
    title.textContent = p.name;
    pathDiv.appendChild(title);
    for (var ni = 0; ni < p.nodes.length; ni++) {
      var node = p.nodes[ni];
      var canBuy = (ni === 0 || p.nodes[ni - 1].owned) && !node.owned;
      var locked = ni > 0 && !p.nodes[ni - 1].owned && !node.owned;
      if (ni > 0) {
        var conn = document.createElement('div');
        conn.className = 'skill-connector' + (p.nodes[ni - 1].owned ? ' owned' : '');
        pathDiv.appendChild(conn);
      }
      var btn = document.createElement('div');
      btn.className = 'skill-node' + (node.owned ? ' owned' : '') + (locked ? ' locked' : '');
      btn.innerHTML = '<div style="font-size:13px;font-weight:700;">' + node.name + '</div><div style="font-size:9px;opacity:0.6;margin-top:2px;">' + node.desc + '</div>' + (node.owned ? '<div style="font-size:9px;color:#5eead4;margin-top:2px;">OWNED</div>' : '<div style="font-size:10px;margin-top:2px;color:' + p.color + ';">' + node.cost + ' tokens</div>');
      btn.dataset.path = p.key;
      btn.dataset.idx = ni;
      btn.onclick = function() {
        var pk = this.dataset.path;
        var idx = parseInt(this.dataset.idx);
        buySkillNode(pk, idx);
      };
      pathDiv.appendChild(btn);
    }
    container.appendChild(pathDiv);
  }
}

function hexToRgb(hex) {
  var h = hex.replace('#', '');
  return parseInt(h.substr(0,2),16) + ',' + parseInt(h.substr(2,2),16) + ',' + parseInt(h.substr(4,2),16);
}

function buySkillNode(path, idx) {
  sfxClick();
  var node = skillTree[path][idx];
  if (node.owned) { showWarning('Already owned!'); return; }
  if (idx > 0 && !skillTree[path][idx - 1].owned) { showWarning('Buy previous node first!'); return; }
  if (fluffTokens >= node.cost) {
    fluffTokens -= node.cost;
    node.owned = true;
    saveProgress();
    renderSkillTree();
    updateHUD();
  } else {
    showWarning('Need ' + (node.cost - fluffTokens) + ' more tokens!');
  }
}

// 12. Egg skins
function buyEggSkin(skinId) {
  sfxClick();
  if (purchasedEggSkins.indexOf(skinId) >= 0) { showWarning('Already purchased!'); return; }
  var skin = null;
  for (var i = 0; i < eggSkins.length; i++) { if (eggSkins[i].id === skinId) skin = eggSkins[i]; }
  if (!skin) return;
  if (fluffTokens >= skin.price) {
    fluffTokens -= skin.price;
    purchasedEggSkins.push(skinId);
    activeEggSkin = skinId;
    saveProgress();
    updateEggSkinShopUI();
    updateSettingsSelectors();
    updateHUD();
  } else {
    showWarning('Need ' + (skin.price - fluffTokens) + ' more tokens!');
  }
}
function updateEggSkinShopUI() {
  for (var i = 0; i < eggSkins.length; i++) {
    var s = eggSkins[i];
    var btnId = s.id + 'SkinBtn';
    var priceId = s.id + 'SkinPrice';
    var btn = document.getElementById(btnId);
    var priceEl = document.getElementById(priceId);
    if (btn && purchasedEggSkins.indexOf(s.id) >= 0) {
      btn.classList.add('active');
      if (priceEl) priceEl.textContent = '(OWNED)';
    }
  }
}
function setEggSkin(val) {
  if (val === 'default' || purchasedEggSkins.indexOf(val) >= 0) {
    activeEggSkin = val;
    saveProgress();
  }
}

// 13. Season pass
function updateSeasonPassUI() {
  var tier = 0;
  for (var i = 0; i < seasonPassTiers.length; i++) {
    if (seasonPassXP >= seasonPassTiers[i]) tier = i + 1;
  }
  seasonPassTier = tier;
  var nextXP = tier < seasonPassTiers.length ? seasonPassTiers[tier] : seasonPassTiers[seasonPassTiers.length - 1];
  var prevXP = tier > 0 ? seasonPassTiers[tier - 1] : 0;
  var pct = tier >= seasonPassTiers.length ? 100 : Math.min(100, ((seasonPassXP - prevXP) / (nextXP - prevXP)) * 100);
  var fillEl = document.getElementById('spBarFill');
  if (fillEl) fillEl.style.width = pct + '%';
  var xpEl = document.getElementById('spXpText');
  if (xpEl) xpEl.textContent = seasonPassXP + ' XP';
  var tierEl = document.getElementById('spTierText');
  if (tierEl) tierEl.textContent = 'Tier ' + tier + '/10';
  // Auto-claim unclaimed rewards
  for (var i = 0; i < tier; i++) {
    if (seasonPassClaimed.indexOf(i) < 0) {
      seasonPassClaimed.push(i);
      var reward = seasonPassRewards[i];
      if (reward.type === 'tokens') {
        fluffTokens += reward.amount;
        floatText('Season Reward: +' + reward.amount + ' tokens!', CW / 2, CH / 3, '#c084fc', 18);
      } else {
        floatText('Season Reward: ' + reward.name + '!', CW / 2, CH / 3, '#c084fc', 18);
      }
      saveProgress();
    }
  }
}
function addSeasonXP(amount) {
  seasonPassXP += amount;
  updateSeasonPassUI();
  saveProgress();
}

// 15. Leaderboard
function addLeaderboardEntry(lvl, catches, tokens) {
  leaderboard.push({ level: lvl, catches: catches, tokens: tokens, date: new Date().toLocaleDateString() });
  leaderboard.sort(function(a, b) { return (b.level * 1000 + b.catches) - (a.level * 1000 + a.catches); });
  if (leaderboard.length > 10) leaderboard = leaderboard.slice(0, 10);
  saveProgress();
}
function openLeaderboard() {
  var list = document.getElementById('leaderboardList');
  list.innerHTML = '';
  if (leaderboard.length === 0) {
    list.innerHTML = '<p style="text-align:center; opacity:0.5; margin:20px 0;">No scores yet. Play a game!</p>';
  }
  for (var i = 0; i < leaderboard.length; i++) {
    var e = leaderboard[i];
    var div = document.createElement('div');
    div.className = 'lb-entry';
    div.innerHTML = '<span class="lb-rank">#' + (i + 1) + '</span><span class="lb-score">Level ' + e.level + ' | ' + e.catches + ' catches | ' + e.tokens + ' tokens</span><span class="lb-date">' + e.date + '</span>';
    list.appendChild(div);
  }
  document.getElementById('leaderboardScreen').classList.add('show');
}
function closeLeaderboard() {
  document.getElementById('leaderboardScreen').classList.remove('show');
}

// 19. Trail effects
function buyTrail(trailId) {
  sfxClick();
  if (purchasedTrails.indexOf(trailId) >= 0) { showWarning('Already purchased!'); return; }
  var trail = null;
  for (var i = 0; i < trailEffects.length; i++) { if (trailEffects[i].id === trailId) trail = trailEffects[i]; }
  if (!trail) return;
  if (fluffTokens >= trail.price) {
    fluffTokens -= trail.price;
    purchasedTrails.push(trailId);
    activeTrailEffect = trailId;
    saveProgress();
    updateTrailShopUI();
    updateSettingsSelectors();
    updateHUD();
  } else {
    showWarning('Need ' + (trail.price - fluffTokens) + ' more tokens!');
  }
}
function updateTrailShopUI() {
  for (var i = 0; i < trailEffects.length; i++) {
    var t = trailEffects[i];
    if (t.price === 0) continue;
    var btnId = t.id + 'TrailBtn';
    var priceId = t.id + 'TrailPrice';
    var btn = document.getElementById(btnId);
    var priceEl = document.getElementById(priceId);
    if (btn && purchasedTrails.indexOf(t.id) >= 0) {
      btn.classList.add('active');
      if (priceEl) priceEl.textContent = '(OWNED)';
    }
  }
}
function setTrailEffect(val) {
  if (purchasedTrails.indexOf(val) >= 0) {
    activeTrailEffect = val;
    saveProgress();
  }
}

// 21. One-hand mode
function toggleOneHand(on) {
  oneHandMode = on;
  try { localStorage.setItem('fluffOneHand', on ? '1' : '0'); } catch(e) {}
}

// 23. Difficulty selector
function setDifficulty(diff) {
  gameDifficulty = diff;
  var btns = document.querySelectorAll('.diff-btn');
  for (var i = 0; i < btns.length; i++) btns[i].classList.remove('active');
  event.target.classList.add('active');
  saveProgress();
}

// 24. High-contrast colorblind mode
function toggleHighContrast(on) {
  highContrastMode = on;
  // Also enable regular colorblind mode if turning on high contrast
  if (on) { colorblindMode = true; document.getElementById('colorblindToggle').checked = true; }
  try { localStorage.setItem('fluffHighContrast', on ? '1' : '0'); } catch(e) {}
}

// Update settings selectors for new features
var _origUpdateSettings = typeof updateSettingsSelectors === 'function' ? updateSettingsSelectors : null;

// Sound effects for new features
function sfxPortalEnter() {
  playTone(400, 0.15, 'sine', 0.08);
  setTimeout(function() { playTone(800, 0.1, 'sine', 0.06); }, 50);
}
function sfxPortalExit() {
  playTone(800, 0.1, 'sine', 0.08);
  setTimeout(function() { playTone(400, 0.15, 'sine', 0.06); }, 50);
}
function sfxGravityFlip() {
  playTone(200, 0.2, 'sine', 0.08);
  playTone(600, 0.15, 'triangle', 0.06);
}
function sfxMerge() {
  playTone(500, 0.15, 'sine', 0.10);
  setTimeout(function() { playTone(700, 0.1, 'sine', 0.08); }, 50);
  setTimeout(function() { playTone(1000, 0.12, 'sine', 0.06); }, 100);
}
function sfxLineErase() {
  playTone(300, 0.1, 'sawtooth', 0.06);
  playTone(150, 0.15, 'square', 0.04);
}
function sfxBossHit() {
  playTone(150, 0.2, 'sawtooth', 0.10);
  playTone(200, 0.15, 'triangle', 0.08);
}
function sfxShrinkRay() {
  playTone(1500, 0.15, 'sine', 0.08);
  setTimeout(function() { playTone(1200, 0.1, 'sine', 0.06); }, 60);
  setTimeout(function() { playTone(900, 0.12, 'sine', 0.05); }, 120);
}
function sfxDecoyPoof() {
  playTone(800, 0.08, 'sine', 0.06);
  playTone(400, 0.1, 'triangle', 0.04);
}
function sfxWindUp() {
  playTone(600, 0.1, 'triangle', 0.06);
  playTone(900, 0.08, 'sine', 0.04);
}

function startGame() {
  initAudio();
  startBgMusic();
  document.getElementById('startScreen').classList.add('gone');
  sessionStartTime = Date.now();
  if (!hasSeenTutorial) {
    initTutorialUI();
    document.getElementById('tutorial').classList.add('show');
    return;
  }
  running = true;
  spawnTimer = 100;
  lastTime = 0;
  bgThemePrev = null; bgThemeCurrent = null; bgThemeTransition = 0;
  comboMultiplier = 1; comboMultiplierTimer = 0;
  shieldTimeLeft = 0; shieldUsed = false; shieldActive = false;
  timeFreezeTimer = 0;
  deathSlowmoTimer = 0; deathSlowmoActive = false;
  goldenZone = null; goldenZoneSpawnTimer = 30000 + Math.random() * 15000;
  lastCatchType = ''; sameTypeComboCount = 0;
  // New feature resets
  gravityFlipZone = null;
  portalPairs = [];
  portalPendingEntry = null;
  shrinkRayTimer = 0;
  catchSlowmoTimer = 0;
  catchSlowmoFactor = 1.0;
  safeZonePhase = 0;
  lastTapTime = 0; lastTapX = 0; lastTapY = 0;
  // Apply skill tree luck3 bonus life
  if (skillTree.luck[2].owned && level >= 10) maxLives = 4;
  lives = maxLives;
  // Countdown timer (item 20)
  countdownTimer = 1600; // 3 numbers + GO = ~3.2 seconds
  countdownPhase = 3;
  spawnTimer = 5000; // delay spawning until countdown done
  document.getElementById('shieldBtn').classList.remove('used');
  updateShieldBtn();
  updateHUD();
}

window.addEventListener('resize', function() {
  CW = window.innerWidth;
  CH = window.innerHeight;
  canvas.width = CW;
  canvas.height = CH;
  if (running && !paused) { paused = true; document.getElementById('pauseOverlay').classList.add('show'); }
});

// Auto-pause on tab switch
document.addEventListener('visibilitychange', function() {
  if (document.hidden && running && !paused) {
    paused = true;
    document.getElementById('pauseOverlay').classList.add('show');
  }
});

loadProgress();
loadAchievements();
// Load colorblind setting
try {
  colorblindMode = localStorage.getItem('fluffColorblind') === '1';
  if (colorblindMode) document.getElementById('colorblindToggle').checked = true;
} catch(e) {}
// Load high contrast setting
try {
  highContrastMode = localStorage.getItem('fluffHighContrast') === '1';
  if (highContrastMode) document.getElementById('highContrastToggle').checked = true;
} catch(e) {}
// Load one-hand mode
try {
  oneHandMode = localStorage.getItem('fluffOneHand') === '1';
  if (oneHandMode) document.getElementById('oneHandToggle').checked = true;
} catch(e) {}
updateHUD();
initLineColorSelector();
updatePrestigeBtn();
updateLineTypeShopUI();
updateBgThemeShopUI();
updateConveyorShopUI();
updateEggSkinShopUI();
updateTrailShopUI();
updateSettingsSelectors();
renderSkillTree();
updateSeasonPassUI();
// Update portal shop UI
document.getElementById('portalPairsLv').textContent = 'Lv:' + portalUpgradeLevel + '/3';
if (portalUpgradeLevel >= 3) document.getElementById('portalPairsPrice').textContent = '(MAX)';
// Set difficulty buttons
var diffBtns2 = document.querySelectorAll('.diff-btn');
for (var dbi = 0; dbi < diffBtns2.length; dbi++) {
  diffBtns2[dbi].classList.remove('active');
  if (diffBtns2[dbi].textContent.toLowerCase() === gameDifficulty) diffBtns2[dbi].classList.add('active');
}
requestAnimationFrame(loop);

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' && running) {
    paused = !paused;
    document.getElementById('pauseOverlay').classList.toggle('show', paused);
  }
  if (e.key === ' ' && !running) {
    e.preventDefault();
    startGame();
  }
});
</script>
</body>
</html>
