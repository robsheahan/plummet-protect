<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>Fluff Flight</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    font-family: sans-serif;
    overflow-y: auto;
  }
  canvas {
    display: block;
    cursor: crosshair;
    touch-action: none;
    margin-top: 10px;
    border-radius: 12px;
    box-shadow: 0 0 40px rgba(255,182,193,0.3);
  }
  #ui {
    position: fixed;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 10px;
    background: rgba(0,0,0,0.5);
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    z-index: 100;
  }
  #ui span { padding: 4px 10px; border-radius: 10px; background: rgba(255,255,255,0.1); }
  #startScreen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(26,26,46,0.92);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    color: #fff;
  }
  #startScreen.gone { display: none; }
  #startScreen h1 {
    font-size: 44px;
    background: linear-gradient(135deg, #ffb6c1, #e0c3fc, #8ec5fc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 10px;
  }
  #startScreen p { opacity: 0.6; margin-bottom: 20px; }
  #startScreen .info { font-size: 14px; line-height: 2; opacity: 0.75; margin-bottom: 24px; text-align: left; max-width: 380px; }
  #startScreen button {
    padding: 14px 44px; font-size: 18px; font-weight: 700;
    border: none; border-radius: 30px;
    background: linear-gradient(135deg, #ffb6c1, #e0c3fc);
    color: #1a1a2e; cursor: pointer;
  }
  #zenBtn {
    position: fixed;
    bottom: 20px; right: 20px;
    width: 50px; height: 50px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
    background: radial-gradient(circle at 35% 35%, #e0c3fc, #8ec5fc);
    color: #333; font-size: 20px;
    cursor: pointer; z-index: 100;
  }
  #zenBtn.off { opacity: 0.3; }
</style>
</head>
<body>

<div id="ui">
  <span id="hudLives">Lives: ****</span>
  <span id="hudLevel">Level 1</span>
  <span id="hudCrash">Crashes: 0/3</span>
  <span id="hudCombo">Combo: 0/10</span>
</div>

<canvas id="c"></canvas>

<button id="zenBtn">&#9775;</button>

<div id="startScreen">
  <h1>Fluff Flight</h1>
  <p>A Physics-Based Juggling Game</p>
  <div class="info">
    Draw lines with your mouse to bounce falling objects.<br>
    Guide them into the Fluff Zone on the right wall.<br>
    You have 4 lives. Every 10 bounces heals you.<br>
    3 crashes resets to Level 1.<br>
    Click the Zen button for slow-motion help.
  </div>
  <button onclick="startGame()">Start Playing</button>
</div>

<script>
// =============================================
// FLUFF FLIGHT - Bulletproof version
// =============================================

// Catch any errors and show them on screen
var errorLog = [];
window.onerror = function(msg, url, line) {
  errorLog.push(msg + ' L' + line);
  return false;
};

var CW = Math.min(700, window.innerWidth - 20);
var CH = Math.min(800, window.innerHeight - 60);
var canvas = document.getElementById('c');
canvas.width = CW;
canvas.height = CH;
var ctx = canvas.getContext('2d');

// Game state
var running = false;
var lives = 4;
var lifeFrac = 0;
var strikes = 0;
var combo = 0;
var level = 1;
var zenOn = false;
var zenTimer = 0;
var zenCooldown = 0;
var spawnTimer = 0;
var objects = [];
var lines = [];
var particles = [];
var texts = [];
var frameCount = 0;

var GRAVITY = 0.12;
var BOUNCE = 0.75;
var LINE_LIFE = 3000;

// Drawing state
var dragging = false;
var dragX1 = 0, dragY1 = 0, dragX2 = 0, dragY2 = 0;

function getXY(e) {
  var r = canvas.getBoundingClientRect();
  if (e.touches) {
    var t = e.touches[0] || e.changedTouches[0];
    return [t.clientX - r.left, t.clientY - r.top];
  }
  return [e.clientX - r.left, e.clientY - r.top];
}

canvas.onmousedown = function(e) {
  if (!running) return;
  var p = getXY(e);
  dragX1 = p[0]; dragY1 = p[1];
  dragging = true;
};
canvas.onmousemove = function(e) {
  if (!dragging) return;
  var p = getXY(e);
  dragX2 = p[0]; dragY2 = p[1];
};
canvas.onmouseup = function(e) {
  if (!dragging) return;
  var p = getXY(e);
  addLine(dragX1, dragY1, p[0], p[1]);
  dragging = false;
};

canvas.ontouchstart = function(e) {
  e.preventDefault();
  if (!running) return;
  var p = getXY(e);
  dragX1 = p[0]; dragY1 = p[1];
  dragging = true;
};
canvas.ontouchmove = function(e) {
  e.preventDefault();
  if (!dragging) return;
  var p = getXY(e);
  dragX2 = p[0]; dragY2 = p[1];
};
canvas.ontouchend = function(e) {
  e.preventDefault();
  if (!dragging) return;
  var p = getXY(e);
  addLine(dragX1, dragY1, p[0], p[1]);
  dragging = false;
};

function addLine(x1, y1, x2, y2) {
  var dx = x2 - x1, dy = y2 - y1;
  var len = Math.sqrt(dx * dx + dy * dy);
  if (len > 25) {
    lines.push({ x1: x1, y1: y1, x2: x2, y2: y2, born: Date.now() });
  }
}

// Fluff zone - gap in the right wall
var WALL_W = 12;
function getZone() {
  var h = Math.max(80, 240 - (level - 1) * 18);
  if (zenOn) h += 60;
  return { x: CW - WALL_W, y: Math.floor(CH / 2 - h / 2), w: WALL_W, h: h };
}

// Spawn
function spawnObj() {
  var types = ['egg', 'vase', 'piano'];
  var type = types[Math.floor(Math.random() * 3)];
  objects.push({
    type: type,
    x: WALL_W + 30 + Math.random() * (CW - WALL_W * 2 - 80),
    y: -40,
    vx: (Math.random() - 0.5) * 0.8,
    vy: 0.2,
    alive: true
  });
}

// Line bounce check
function checkBounce(obj) {
  var now = Date.now();
  for (var i = 0; i < lines.length; i++) {
    var L = lines[i];
    if (now - L.born > LINE_LIFE) continue;

    var lx = L.x2 - L.x1;
    var ly = L.y2 - L.y1;
    var len = Math.sqrt(lx * lx + ly * ly);
    if (len < 5) continue;

    // Line normal (ensure it points up)
    var nx = -ly / len;
    var ny = lx / len;
    if (ny > 0) { nx = -nx; ny = -ny; }

    // Distance from object to line
    var dx = obj.x - L.x1;
    var dy = obj.y - L.y1;
    var dist = dx * nx + dy * ny;

    // Projection along line
    var proj = (dx * lx + dy * ly) / (len * len);
    if (proj < -0.1 || proj > 1.1) continue;

    // Close enough and moving toward line?
    if (dist > 0 && dist < 22) {
      var vn = obj.vx * nx + obj.vy * ny;
      if (vn < 0) {
        // Reflect
        obj.vx = obj.vx - 2 * vn * nx;
        obj.vy = obj.vy - 2 * vn * ny;
        obj.vx *= BOUNCE;
        obj.vy *= BOUNCE;
        // Push out
        obj.x += nx * (22 - dist);
        obj.y += ny * (22 - dist);
        return true;
      }
    }
  }
  return false;
}

// Particle burst
function burst(x, y, color, n) {
  for (var i = 0; i < n; i++) {
    var a = Math.random() * Math.PI * 2;
    var s = 1 + Math.random() * 4;
    particles.push({
      x: x, y: y,
      vx: Math.cos(a) * s,
      vy: Math.sin(a) * s - 2,
      life: 1.0,
      color: color,
      size: 2 + Math.random() * 4
    });
  }
}

function floatText(msg, x, y, color) {
  texts.push({ t: msg, x: x, y: y, life: 1.0, color: color });
}

function updateHUD() {
  var lifeStr = '';
  for (var i = 0; i < 4; i++) lifeStr += (i < lives) ? '*' : '.';
  document.getElementById('hudLives').textContent = 'Lives: ' + lifeStr;
  document.getElementById('hudLevel').textContent = 'Level ' + level;
  document.getElementById('hudCrash').textContent = 'Crashes: ' + strikes + '/3';
  document.getElementById('hudCombo').textContent = 'Combo: ' + combo + '/10';
}

// Zen
document.getElementById('zenBtn').onclick = function() {
  if (!running || zenOn || zenCooldown > 0) return;
  zenOn = true;
  zenTimer = 5000;
  this.classList.add('off');
};

// Game events
function onBounce(obj) {
  combo++;
  floatText('+1', obj.x, obj.y - 25, '#c4b5fd');
  if (combo >= 10) {
    combo = 0;
    if (lives < 4) {
      lifeFrac++;
      if (lifeFrac >= 4) { lifeFrac = 0; lives = Math.min(4, lives + 1); }
      floatText('+0.25 Life!', CW / 2, CH / 2, '#66bb6a');
    }
  }
  updateHUD();
}

function onCrash(obj) {
  burst(obj.x, obj.y, '#ff6b6b', 18);
  floatText('CRASH!', obj.x, obj.y - 25, '#ff6b6b');
  obj.alive = false;
  strikes++;
  combo = 0;
  updateHUD();
  if (strikes >= 3) {
    setTimeout(function() {
      lives = 4; lifeFrac = 0; strikes = 0; combo = 0; level = 1;
      objects = []; lines = []; particles = []; texts = [];
      spawnTimer = 800; zenOn = false; zenTimer = 0; zenCooldown = 0;
      document.getElementById('zenBtn').classList.remove('off');
      updateHUD();
    }, 800);
  }
}

function onCatch(obj) {
  burst(obj.x, obj.y, '#66bb6a', 15);
  floatText('Caught!', obj.x, obj.y - 25, '#66bb6a');
  obj.alive = false;
}

// MAIN LOOP
var lastTime = 0;

function loop(now) {
  try {
    requestAnimationFrame(loop);
    if (!running) return;

    frameCount++;
    var dt = 0;
    if (lastTime > 0) {
      dt = now - lastTime;
      if (dt > 50) dt = 16;
    } else {
      dt = 16;
    }
    lastTime = now;

    var grav = zenOn ? GRAVITY * 0.5 : GRAVITY;

    // Zen
    if (zenOn) {
      zenTimer -= dt;
      if (zenTimer <= 0) { zenOn = false; zenCooldown = 20000; }
    }
    if (zenCooldown > 0) {
      zenCooldown -= dt;
      if (zenCooldown <= 0) {
        zenCooldown = 0;
        document.getElementById('zenBtn').classList.remove('off');
      }
    }

    // Spawn
    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      var activeCount = 0;
      for (var i = 0; i < objects.length; i++) { if (objects[i].alive) activeCount++; }
      var maxObj = Math.min(2 + Math.floor(level / 2), 5);
      if (activeCount < maxObj) spawnObj();
      spawnTimer = Math.max(1200, 3200 - level * 200);
    }

    // Expire old lines
    var now2 = Date.now();
    var newLines = [];
    for (var i = 0; i < lines.length; i++) {
      if (now2 - lines[i].born < LINE_LIFE) newLines.push(lines[i]);
    }
    lines = newLines;

    // Update objects
    var zone = getZone();
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (!obj.alive) continue;

      obj.vy += grav;
      obj.vx *= 0.998;  // air friction
      obj.vy *= 0.998;
      obj.x += obj.vx;
      obj.y += obj.vy;

      // Left wall
      if (obj.x < WALL_W + 10) { obj.x = WALL_W + 10; obj.vx = Math.abs(obj.vx) * 0.6; }
      // Right wall - bounce UNLESS object is in the fluff zone gap
      var inGap = (obj.y > zone.y && obj.y < zone.y + zone.h);
      if (!inGap && obj.x > CW - WALL_W - 10) {
        obj.x = CW - WALL_W - 10;
        obj.vx = -Math.abs(obj.vx) * 0.6;
      }

      // Line bounce
      if (checkBounce(obj)) {
        onBounce(obj);
      }

      // Floor crash
      if (obj.y > CH - WALL_W - 5) {
        onCrash(obj);
        continue;
      }

      // Fluff zone catch (right wall)
      if (obj.x > zone.x && obj.y > zone.y && obj.y < zone.y + zone.h) {
        onCatch(obj);
      }
    }

    // Clean dead objects
    var alive = [];
    for (var i = 0; i < objects.length; i++) {
      if (objects[i].alive) alive.push(objects[i]);
    }
    objects = alive;

    // Update particles
    for (var i = particles.length - 1; i >= 0; i--) {
      var p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.08;
      p.life -= 0.02;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Update floating texts
    for (var i = texts.length - 1; i >= 0; i--) {
      texts[i].y -= 0.8;
      texts[i].life -= 0.015;
      if (texts[i].life <= 0) texts.splice(i, 1);
    }

    // ======= DRAW =======
    // Background gradient
    var grad = ctx.createLinearGradient(0, 0, 0, CH);
    grad.addColorStop(0, '#fdf2f8');
    grad.addColorStop(0.5, '#fce7f3');
    grad.addColorStop(1, '#f3e8ff');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CW, CH);

    // Clouds
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#ffffff';
    var ct = now * 0.00006;
    for (var i = 0; i < 4; i++) {
      var cx = ((i * 190 + ct * 30 * (i + 1)) % (CW + 200)) - 100;
      var cy = 60 + i * 70;
      ctx.beginPath();
      ctx.arc(cx, cy, 25, 0, Math.PI * 2);
      ctx.arc(cx + 22, cy - 6, 18, 0, Math.PI * 2);
      ctx.arc(cx + 44, cy, 22, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;

    // Zen overlay
    if (zenOn) {
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#8ec5fc';
      ctx.fillRect(0, 0, CW, CH);
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#8ec5fc';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Zen Mode ' + Math.ceil(zenTimer / 1000) + 's', CW / 2, 80);
    }

    // WALLS - visible solid walls
    var wallW = 12;
    ctx.fillStyle = '#6b7280';

    // Left wall
    ctx.fillRect(0, 0, wallW, CH);

    // Floor
    ctx.fillRect(0, CH - wallW, CW, wallW);

    // Right wall - TOP section (above fluff zone)
    ctx.fillRect(CW - wallW, 0, wallW, zone.y);

    // Right wall - BOTTOM section (below fluff zone)
    ctx.fillRect(CW - wallW, zone.y + zone.h, wallW, CH - zone.y - zone.h);

    // FLUFF ZONE - glowing gap in the right wall
    var pulse = 0.5 + 0.3 * Math.sin(now * 0.004);
    ctx.fillStyle = 'rgba(74, 222, 128, ' + pulse + ')';
    ctx.fillRect(CW - wallW, zone.y, wallW, zone.h);

    // Glow effect around the gap
    ctx.shadowColor = '#4ade80';
    ctx.shadowBlur = 20;
    ctx.fillStyle = 'rgba(74, 222, 128, 0.3)';
    ctx.fillRect(CW - wallW - 15, zone.y - 5, wallW + 20, zone.h + 10);
    ctx.shadowBlur = 0;

    // Arrows pointing at the gap
    ctx.fillStyle = '#4ade80';
    ctx.globalAlpha = 0.6 + 0.3 * Math.sin(now * 0.005);
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('>>>', CW - wallW - 20, zone.y + zone.h / 2 + 6);
    ctx.globalAlpha = 1.0;

    // Label next to the gap
    ctx.save();
    ctx.translate(CW - wallW - 40, zone.y + zone.h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#4ade80';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('FLUFF ZONE', 0, 0);
    ctx.restore();

    // MATTRESS LINES
    for (var i = 0; i < lines.length; i++) {
      var L = lines[i];
      var age = now2 - L.born;
      var alpha = Math.max(0, 1 - age / LINE_LIFE);
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#a78bfa';
      ctx.lineWidth = 10;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(L.x1, L.y1);
      ctx.lineTo(L.x2, L.y2);
      ctx.stroke();
      ctx.strokeStyle = '#e9e1ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(L.x1, L.y1);
      ctx.lineTo(L.x2, L.y2);
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }

    // DRAWING PREVIEW
    if (dragging) {
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#a78bfa';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(dragX1, dragY1);
      ctx.lineTo(dragX2, dragY2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1.0;
    }

    // OBJECTS
    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];
      if (!obj.alive) continue;

      ctx.save();
      ctx.translate(obj.x, obj.y);

      if (obj.type === 'egg') {
        // Egg
        ctx.beginPath();
        ctx.ellipse(0, 0, 13, 17, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#fef3c7';
        ctx.fill();
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Eyes
        ctx.fillStyle = '#7c6545';
        ctx.beginPath(); ctx.arc(-4, -4, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -4, 2, 0, Math.PI * 2); ctx.fill();
        // Smile
        ctx.beginPath(); ctx.arc(0, 1, 4, 0.2, Math.PI - 0.2); ctx.strokeStyle = '#7c6545'; ctx.lineWidth = 1.5; ctx.stroke();
      } else if (obj.type === 'vase') {
        // Vase body
        ctx.beginPath();
        ctx.moveTo(-11, 18);
        ctx.quadraticCurveTo(-15, 0, -8, -13);
        ctx.lineTo(-5, -17);
        ctx.lineTo(5, -17);
        ctx.lineTo(8, -13);
        ctx.quadraticCurveTo(15, 0, 11, 18);
        ctx.closePath();
        ctx.fillStyle = '#fda4af';
        ctx.fill();
        ctx.strokeStyle = '#e57373';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Flower
        ctx.fillStyle = '#ffffff';
        for (var j = 0; j < 5; j++) {
          var fa = (j / 5) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(Math.cos(fa) * 5, -24 + Math.sin(fa) * 5, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.fillStyle = '#fde68a';
        ctx.beginPath(); ctx.arc(0, -24, 3, 0, Math.PI * 2); ctx.fill();
      } else {
        // Piano
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(-20, -14, 40, 28);
        ctx.strokeStyle = '#93c5fd';
        ctx.lineWidth = 2;
        ctx.strokeRect(-20, -14, 40, 28);
        // Keys
        for (var j = 0; j < 7; j++) {
          ctx.fillStyle = (j % 2 === 0) ? '#ffffff' : '#334155';
          ctx.fillRect(-18 + j * 5.2, -4, 4.5, 16);
        }
      }

      ctx.restore();
    }

    // PARTICLES
    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0.5, p.size * p.life), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1.0;

    // FLOATING TEXTS
    for (var i = 0; i < texts.length; i++) {
      var t = texts[i];
      ctx.globalAlpha = Math.max(0, t.life);
      ctx.fillStyle = t.color;
      ctx.font = 'bold 15px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(t.t, t.x, t.y);
    }
    ctx.globalAlpha = 1.0;


  } catch(err) {
    errorLog.push(err.message);
  }
}

function startGame() {
  document.getElementById('startScreen').classList.add('gone');
  running = true;
  spawnTimer = 100; // spawn almost immediately
  lastTime = 0;
  updateHUD();
}

updateHUD();
requestAnimationFrame(loop);
</script>
</body>
</html>
